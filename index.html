<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Critical Path Finder — CSV Only (Full Depth, Free Float, Bi‑directional Build)</title>
<style>
  :root { --bg:#fff; --fg:#111; --muted:#666; --panel:#f6f8fa; --border:#e1e4e8; }
  body { font-family: Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; color: var(--fg); background: var(--bg); }
  h1 { margin-top: 0; }
  .row { margin: 0.75rem 0; }
  input[type="text"], select { padding: 0.45rem; }
  input[type="text"] { width: 360px; }
  button { padding: 0.5rem 0.9rem; margin-right: 0.5rem; cursor: pointer; }
  #log { white-space: pre-wrap; background: var(--panel); border: 1px solid var(--border); padding: 0.75rem; border-radius: 6px; min-height: 8rem; }
  .muted { color: var(--muted); font-size: 0.9rem; }
  .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 0.75rem; }
  label { font-weight: 600; display: block; margin-bottom: 0.25rem; }
  .small { font-size: 0.9rem; }
</style>
</head>
<body>
  <h1>Critical Path Finder — CSV Only (Full Depth, Free Float)</h1>

  <div class="row controls">
    <div>
      <label for="fileInput">CSV File (.csv)</label>
      <input id="fileInput" type="file" accept=".csv" />
      <div class="muted small">Runs entirely in your browser (offline).</div>
    </div>

    <div>
      <label for="startId">Starting Activity ID</label>
      <input id="startId" type="text" placeholder="Enter an Activity ID from the CSV" />
    </div>

    <div>
      <label for="unitSelect">Time Unit for FF & Lags</label>
      <select id="unitSelect">
        <option value="days" selected>Days</option>
        <option value="hours">Hours</option>
      </select>
      <div class="muted small">Lag strings with explicit units (e.g., +8h) are respected.</div>
    </div>

    <div>
      <label for="dateLocale">Date Format (Start/Finish)</label>
      <select id="dateLocale">
        <option value="us" selected>US — MM/DD/YYYY [HH:MM]</option>
        <option value="intl">Intl — DD/MM/YYYY [HH:MM]</option>
        <option value="auto">Auto (try multiple patterns)</option>
      </select>
      <div class="muted small">Also supports 05-Jan-2025 08:00, etc.</div>
    </div>
  </div>

  <div class="row">
    <button id="runBtn">Run Analysis</button>
    <button id="resetBtn">Reset</button>
    <button id="downloadBtn" disabled>Download Top‑10 Paths (CSV)</button>
  </div>

  <div class="row">
    <strong>Notes</strong>
    <ul class="small">
      <li>Traverses <em>all</em> predecessors recursively (full depth), with cycle protection.</li>
      <li>Builds the backward graph from both <code>Predecessor*</code> and inverted <code>Successor*</code> columns.</li>
      <li>Per‑edge Free Float is computed from <code>Start</code>/<code>Finish</code> and relationship + lag.</li>
      <li>Top‑10 paths are ranked by the sum of per‑edge Free Float (lowest totals first).</li>
      <li>Export CSV puts one path per row, listing all Activity IDs on that path from the activity of interest backward.</li>
    </ul>
  </div>

  <h3>Log</h3>
  <div id="log">Load a CSV, enter a Starting Activity ID, configure options, then click “Run Analysis”.</div>

<script>
/* ========================== CSV Parsing ========================== */
function parseCSV(text, delimiter = ",") {
  const rows = [];
  let row = [], val = "", inQuotes = false;
  for (let i = 0; i < text.length; i++) {
    const c = text[i], n = text[i+1];
    if (inQuotes) {
      if (c === '"') { if (n === '"') { val += '"'; i++; } else { inQuotes = false; } }
      else { val += c; }
    } else {
      if (c === '"') inQuotes = true;
      else if (c === delimiter) { row.push(val); val = ""; }
      else if (c === "\r") { /* ignore */ }
      else if (c === "\n") { row.push(val); rows.push(row); row = []; val = ""; }
      else { val += c; }
    }
  }
  row.push(val); rows.push(row);
  if (rows.length && rows[rows.length-1].length === 1 && rows[rows.length-1][0] === "") rows.pop();
  return rows;
}
function rowsToObjects(rows) {
  if (!rows || rows.length === 0) return { headersRaw: [], headersKey: [], records: [] };
  const headersRaw = rows[0].map(h => (h ?? "").toString().trim());
  const headersKey = headersRaw.map(h => h.toLowerCase());
  const records = [];
  for (let r = 1; r < rows.length; r++) {
    const obj = {};
    for (let c = 0; c < headersRaw.length; c++) {
      const k = headersRaw[c];
      obj[k] = (rows[r][c] ?? "").toString();
      obj["__" + k.toLowerCase()] = (rows[r][c] ?? "").toString();
    }
    records.push(obj);
  }
  return { headersRaw, headersKey, records };
}
function resolveColumn(headersKey, headersRaw, candidates) {
  for (const cand of candidates) {
    const idx = headersKey.indexOf(cand.toLowerCase());
    if (idx !== -1) return headersRaw[idx];
  }
  return null;
}
const norm = s => (s ?? "").toString().trim();

/* ========================== Date Parsing ========================== */
function parseDateFlexible(s, localePref = "us") {
  if (!s) return null;
  const str = s.trim();
  if (!str) return null;

  // Native parse supports ISO and some localized forms
  const t = Date.parse(str);
  if (!Number.isNaN(t)) return new Date(t);

  // MM/DD/YYYY or DD/MM/YYYY with optional time HH:MM[:SS]
  const slashRe = /^(\d{1,2})\/\-\/\-(?: T:(\d{2})(?::(\d{2}))?)?$/;
  const mSlash = slashRe.exec(str);
  if (mSlash) {
    let a = +mSlash[1], b = +mSlash[2], y = +mSlash[3]; if (y < 100) y += 2000;
    let M, D; if (localePref === "intl") { D = a; M = b; } else { M = a; D = b; }
    const hh = +(mSlash[4]||0), mm = +(mSlash[5]||0), ss = +(mSlash[6]||0);
    return new Date(y, M-1, D, hh, mm, ss);
  }

  // 05-Jan-2025 08:00 or 5-Jan-25
  const monMap = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11};
  const dashMon = /^(\d{1,2})- - (?: T:(\d{2})(?::(\d{2}))?)?$/;
  const mDash = dashMon.exec(str);
  if (mDash) {
    const D = +mDash[1], mon = monMap[mDash[2].toLowerCase()];
    if (mon != null) {
      let y = +mDash[3]; if (y < 100) y += 2000;
      const hh = +(mDash[4]||0), mm = +(mDash[5]||0), ss = +(mDash[6]||0);
      return new Date(y, mon, D, hh, mm, ss);
    }
  }

  if (localePref === "auto") return parseDateFlexible(str, "us") || parseDateFlexible(str, "intl");
  return null;
}

/* ====================== Relationship & Lag Parsing ====================== */
function parseRelationList(str) {
  // Accepts: "A100 FS+2d; A200 SS-8h" OR just "A100,A200"
  if (!str) return [];
  const items = str.split(/[,;\n]+/).map(x => x.trim()).filter(Boolean);
  const out = [];
  for (const it of items) {
    const idMatch = it.match(/^[^\s()]+/);
    const otherId = idMatch ? idMatch[0].trim() : it;
    const relMatch = it.match(/\b(FS|SS|FF|SF)\b/i);
    const type = relMatch ? relMatch[1].toUpperCase() : "FS";
    const lagMatch = it.match(/([+-]\s*\d*\.?\d*\s*(?:d|h|m)?)/i);
    let lagVal = 0, lagUnitRaw = null;
    if (lagMatch) {
      const raw = lagMatch[1].replace(/\s+/g,"");
      const unitM = raw.match(/[dhm]$/i);
      lagUnitRaw = unitM ? unitM[0].toLowerCase() : null;
      const num = raw.replace(/[dhm]/ig,"");
      const parsed = parseFloat(num);
      lagVal = Number.isNaN(parsed) ? 0 : parsed;
    }
    out.push({ otherId, type, lagVal, lagUnitRaw });
  }
  return out;
}
function parseSimpleIDs(str) {
  if (!str) return [];
  return str.split(/[,;]+/).map(s => norm(s)).filter(Boolean).map(x => ({ otherId: x, type:"FS", lagVal:0, lagUnitRaw:null }));
}

/* ============================= Model Build ============================= */
function buildModel(csvObj, opts) {
  const { headersRaw, headersKey, records } = csvObj;
  const idCol     = resolveColumn(headersKey, headersRaw, ["Activity ID"]);
  const startCol  = resolveColumn(headersKey, headersRaw, ["Start"]);
  const finishCol = resolveColumn(headersKey, headersRaw, ["Finish"]);
  const predDetailsCol = resolveColumn(headersKey, headersRaw, ["Predecessor Details"]);
  const predsCol       = resolveColumn(headersKey, headersRaw, ["Predecessors"]);
  const succDetailsCol = resolveColumn(headersKey, headersRaw, ["Successor Details"]);
  const succsCol       = resolveColumn(headersKey, headersRaw, ["Successors"]);

  if (!idCol)     throw new Error('Required column "Activity ID" not found.');
  if (!startCol)  throw new Error('Required column "Start" not found.');
  if (!finishCol) throw new Error('Required column "Finish" not found.');
  if (!predDetailsCol && !predsCol && !succDetailsCol && !succsCol) {
    throw new Error('Need at least one of: "Predecessor Details", "Predecessors", "Successor Details", or "Successors".');
  }

  // Nodes (ES/EF from Start/Finish)
  const nodes = new Map(); // id -> { id, ES, EF, startStr, finishStr }
  for (const r of records) {
    const id = norm(r[idCol]);
    if (!id) continue;
    const ES = parseDateFlexible(r[startCol], opts.dateLocale);
    const EF = parseDateFlexible(r[finishCol], opts.dateLocale);
    nodes.set(id, { id, ES, EF, startStr: r[startCol] ?? "", finishStr: r[finishCol] ?? "" });
  }

  // predMap: successorId -> array of { predId, type, lagVal, lagUnitRaw }
  const predMap = new Map();
  const addEdge = (succId, predId, type, lagVal, lagUnitRaw) => {
    succId = norm(succId); predId = norm(predId);
    if (!succId || !predId) return;
    const list = predMap.get(succId) || [];
    // Dedup by key
    const key = `${succId}||${predId}||${type}||${lagVal}||${lagUnitRaw || ""}`;
    if (!list._keys) list._keys = new Set();
    if (!list._keys.has(key)) {
      list._keys.add(key);
      list.push({ predId, type: (type || "FS").toUpperCase(), lagVal: lagVal || 0, lagUnitRaw: lagUnitRaw || null });
      predMap.set(succId, list);
    }
  };

  // 1) From Predecessor Details / Predecessors (succ row lists its predecessors)
  for (const r of records) {
    const succId = norm(r[idCol]);
    if (!succId) continue;

    if (predDetailsCol && r[predDetailsCol]) {
      const items = parseRelationList(r[predDetailsCol]);
      for (const it of items) addEdge(succId, it.otherId, it.type, it.lagVal, it.lagUnitRaw);
    }
    if (predsCol && r[predsCol] && (!predDetailsCol || !r[predDetailsCol])) {
      const items = parseSimpleIDs(r[predsCol]);
      for (const it of items) addEdge(succId, it.otherId, it.type, it.lagVal, it.lagUnitRaw);
    }
  }

  // 2) Invert Successor Details / Successors (pred row lists its successors)
  for (const r of records) {
    const predId = norm(r[idCol]);
    if (!predId) continue;

    if (succDetailsCol && r[succDetailsCol]) {
      const items = parseRelationList(r[succDetailsCol]);
      for (const it of items) addEdge(it.otherId, predId, it.type, it.lagVal, it.lagUnitRaw); // succ <- pred
    }
    if (succsCol && r[succsCol] && (!succDetailsCol || !r[succDetailsCol])) {
      const items = parseSimpleIDs(r[succsCol]);
      for (const it of items) addEdge(it.otherId, predId, it.type, it.lagVal, it.lagUnitRaw); // succ <- pred
    }
  }

  // Clean ephemeral _keys
  for (const [k, arr] of predMap.entries()) {
    if (arr && arr._keys) delete arr._keys;
    predMap.set(k, arr);
  }

  return { nodes, predMap, idCol, startCol, finishCol };
}

/* ========================= Free Float Computation ========================= */
function unitToMs(unitSel) { return unitSel === "hours" ? 3600000 : 86400000; }
function lagToMs(lagVal, lagUnitRaw, unitSel) {
  if (!lagVal) return 0;
  if (!lagUnitRaw) return lagVal * unitToMs(unitSel);
  switch (lagUnitRaw) {
    case "d": return lagVal * 86400000;
    case "h": return lagVal * 3600000;
    case "m": return lagVal * 60000;
    default:  return lagVal * unitToMs(unitSel);
  }
}
function edgeFreeFloat(predNode, succNode, relType, lagVal, lagUnitRaw, unitSel) {
  const oneUnitMs = unitToMs(unitSel);
  const lagMs = lagToMs(lagVal, lagUnitRaw, unitSel);

  const ES_P = predNode?.ES || null;
  const EF_P = predNode?.EF || null;
  const ES_S = succNode?.ES || null;
  const EF_S = succNode?.EF || null;

  let base = null, target = null;
  switch ((relType || "FS").toUpperCase()) {
    case "SS": base = ES_P; target = ES_S; break;
    case "FF": base = EF_P; target = EF_S; break;
    case "SF": base = ES_P; target = EF_S; break;
    case "FS":
    default:   base = EF_P; target = ES_S; break;
  }

  if (!base || !target) return { ffUnits: 0, ms: 0, missingDates: true };

  const ms = target.getTime() - (base.getTime() + lagMs);
  return { ffUnits: ms / oneUnitMs, ms, missingDates: false };
}

/* =============================== Full-Depth DFS =============================== */
function enumeratePaths(model, startId, unitSel, maxPaths = 1000000) {
  const { nodes, predMap } = model;
  if (!nodes.has(startId)) throw new Error(`Starting Activity ID "${startId}" not found in file.`);

  const results = [];                     // { nodes: [ids], edges: [...], score }
  const nodesOnPath = [startId];          // Start with activity of interest
  const edgesOnPath = [];                 // per-edge info aligned with transitions
  const onStack = new Set([startId]);     // cycle detection

  function dfs(currSuccId) {
    if (results.length >= maxPaths) return;

    const preds = predMap.get(currSuccId) || [];
    if (preds.length === 0) {
      // Leaf reached — finalize
      const score = edgesOnPath.reduce((acc, e) => acc + (Number(e.ffUnits) || 0), 0);
      results.push({ nodes: [...nodesOnPath], edges: [...edgesOnPath], score });
      return;
    }

    for (const rel of preds) {
      const predId = norm(rel.predId);
      const type = (rel.type || "FS").toUpperCase();
      const predNode = nodes.get(predId) || null;
      const succNode = nodes.get(currSuccId) || null;
      const ff = edgeFreeFloat(predNode, succNode, type, rel.lagVal || 0, rel.lagUnitRaw || null, unitSel);

      edgesOnPath.push({
        succId: currSuccId, predId, type,
        lagVal: rel.lagVal || 0, lagUnitRaw: rel.lagUnitRaw || null,
        ffUnits: ff.ffUnits, flags: { missingDates: ff.missingDates, unknownPred: !predNode }
      });
      nodesOnPath.push(predId);

      if (onStack.has(predId)) {
        // Cycle: record partial and do not recurse deeper
        const score = edgesOnPath.reduce((acc, e) => acc + (Number(e.ffUnits) || 0), 0);
        results.push({ nodes: [...nodesOnPath, "(cycle)"], edges: [...edgesOnPath], score, cycle: true });
      } else {
        onStack.add(predId);
        dfs(predId);
        onStack.delete(predId);
      }

      nodesOnPath.pop();
      edgesOnPath.pop();

      if (results.length >= maxPaths) break;
    }
  }

  dfs(startId);
  return results;
}

/* ============================ Ranking & Export ============================ */
function rankPathsByFF(paths) {
  return paths
    .map((p, idx) => ({ ...p, idx }))
    .sort((a, b) => a.score - b.score)
    .slice(0, 10);
}
function buildPathsCSV(topPaths, unitSel) {
  const u = unitSel === "hours" ? "h" : "d";
  const maxLen = topPaths.reduce((m, p) => Math.max(m, p.nodes.length), 0);

  const header = ["Path","Rank","NodeCount",`Total FF (${u})`,"Path String"];
  for (let i = 1; i <= maxLen; i++) header.push(`Node_${i}`);

  const rows = [header];
  topPaths.forEach((p, i) => {
    const pathString = p.nodes.join(" <- ");
    const base = [`Path_${i+1}`, i+1, p.nodes.length, p.score.toFixed(4), pathString];
    const nodeCols = Array.from({ length: maxLen }, (_, k) => p.nodes[k] ?? "");
    rows.push([...base, ...nodeCols]);
  });
  return rows;
}
function toCSV(rows) {
  const esc = v => { const s = (v ?? "").toString(); return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s; };
  return rows.map(r => r.map(esc).join(",")).join("\n");
}
function downloadCSV(filename, text) {
  const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement("a"), { href: url, download: filename });
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
}

/* ================================ UI Logic ================================ */
const fileInput   = document.getElementById("fileInput");
const startIdInput= document.getElementById("startId");
const unitSelect  = document.getElementById("unitSelect");
const dateLocale  = document.getElementById("dateLocale");
const runBtn      = document.getElementById("runBtn");
const resetBtn    = document.getElementById("resetBtn");
const downloadBtn = document.getElementById("downloadBtn");
const logEl       = document.getElementById("log");

let lastTopPaths = null;
let lastUnitSel = "days";

function log(msg) { logEl.textContent = msg; }

runBtn.addEventListener("click", () => {
  const file = fileInput.files && fileInput.files[0];
  if (!file) return log("Please choose a .csv file first.");
  const startId = norm(startIdInput.value);
  if (!startId) return log("Please enter a Starting Activity ID.");

  const unitSel = unitSelect.value;
  const localeSel = dateLocale.value;

  const reader = new FileReader();
  reader.onerror = () => log("Failed to read the CSV. Please try again.");
  reader.onload = () => {
    try {
      const text = reader.result.toString();
      const rows = parseCSV(text, ",");
      const csvObj = rowsToObjects(rows);
      const model = buildModel(csvObj, { dateLocale: localeSel });

      if (!model.nodes.has(startId)) {
        log(`Starting Activity ID "${startId}" not found. Check exact ID and case.`);
        lastTopPaths = null; downloadBtn.disabled = true; return;
      }

      const allPaths = enumeratePaths(model, startId, unitSel, 1000000);
      if (allPaths.length === 0) {
        log(`No predecessor paths found starting from "${startId}".`);
        lastTopPaths = null; downloadBtn.disabled = true; return;
      }

      const topPaths = rankPathsByFF(allPaths);
      lastTopPaths = topPaths;
      lastUnitSel = unitSel;

      const u = unitSel === "hours" ? "h" : "d";
      let preview = `Found ${allPaths.length} path(s). Showing Top ${topPaths.length} by lowest total Free Float:\n\n`;
      topPaths.forEach((p, i) => {
        preview += `#${i+1}  Total FF=${p.score.toFixed(2)}${u}  Path: ${p.nodes.join(" <- ")}\n`;
      });
      if (allPaths.length >= 1000000) {
        preview += `\nNote: Path enumeration reached the safety limit (1,000,000). Increase if needed.`;
      }
      log(preview);
      downloadBtn.disabled = false;

    } catch (e) {
      console.error(e);
      log("Error: " + (e && e.message ? e.message : e));
      lastTopPaths = null; downloadBtn.disabled = true;
    }
  };
  reader.readAsText(file, "utf-8");
});

downloadBtn.addEventListener("click", () => {
  if (!lastTopPaths) return;
  const rows = buildPathsCSV(lastTopPaths, lastUnitSel);
  downloadCSV("critical_paths_top10_paths.csv", toCSV(rows));
});

resetBtn.addEventListener("click", () => {
  fileInput.value = "";
  startIdInput.value = "";
  lastTopPaths = null;
  downloadBtn.disabled = true;
  log("Load a CSV, enter a Starting Activity ID, configure options, then click “Run Analysis”.");
});
</script>
</body>
</html>
