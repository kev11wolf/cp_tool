<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>P6 XLSX Backward Tracer (Large Datasets)</title>
  <style>
    :root { --bg: #fff; --fg: #111; --muted:#555; --card:#f8f8f8; }
    body { font-family: Arial, sans-serif; background: var(--bg); color: var(--fg); margin: 0; padding: 20px; }
    h1 { font-size: 1.5rem; margin-bottom: 8px; }
    .section { margin-bottom: 20px; padding: 12px; border: 1px solid #eee; border-radius: 8px; background: #fff; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    input[type="file"] { padding: 8px; }
    select, button, input { padding: 8px 10px; font-size: 14px; }
    button { cursor: pointer; }
    #mappingSection { display: none; }
    #resultsSection { display: none; }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: #f4f4f4; }
    #colMap { list-style: none; padding-left: 0; margin: 0; }
    #colMap li { margin: 4px 0; }
    .progress { display: inline-block; padding: 6px 12px; border-radius: 4px; background: #eef; color: #006; }
    .sectionTitle { font-weight: bold; margin-bottom: 6px; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <h1>P6 XLSX Backward Tracer (Large Datasets)</h1>

  <div class="section" id="introSection">
    <p>Upload a single Excel export (xlsx) from P6. The script auto-detects columns by header names and computes backward critical paths. Large datasets (e.g., ~25k rows) are handled efficiently with progress updates.</p>
    <div class="row">
      <input type="file" id="xlsxInput" accept=".xlsx,.xls" />
      <button id="loadBtn" disabled>Load and Parse</button>
      <span id="progress" class="progress hidden" aria-live="polite"></span>
    </div>
  </div>

  <div class="section hidden" id="mappingSection" aria-label="Mapping section">
    <div class="sectionTitle">Detected Columns</div>
    <ul id="colMap" style="margin:0 0 10px 0;"></ul>

    <div class="sectionTitle" style="margin-top:6px;">Start Activity</div>
    <div class="row" style="align-items:center;">
      <select id="startActivity" aria-label="Start activity dropdown"></select>
      <div style="margin-left:8px;">
        <label for="manualStart" style="margin-right:6px;">Or manual Start ID:</label>
        <input type="text" id="manualStart" placeholder="e.g. dpfg8620" />
        <button id="applyManualStart" title="Use manual Start ID for tracing">Use Start ID</button>
      </div>
    </div>

    <div class="row" style="margin-top:8px;">
      <button id="traceBtn" style="margin-right:8px;">Trace Backward Paths</button>
      <button id="exportBtn" disabled>Export Top 10 as CSV</button>
    </div>
  </div>

  <div class="section hidden" id="resultsSection" aria-label="Results section">
    <div class="sectionTitle">Top 10 Backward Critical Paths</div>
    <table id="resultsTable" aria-label="Top 10 backward paths">
      <thead>
        <tr>
          <th>Path Score (lower = more critical)</th>
          <th>Path IDs</th>
          <th>Path Names</th>
          <th>Node Count</th>
        </tr>
      </thead>
      <tbody id="resultsBody"></tbody>
    </table>
  </div>

  <!-- SheetJS library -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>

  <script>
    // Helpers
    const normalizeHeader = (h) => (h || "").toString().trim().toLowerCase();

    // Global data (careful with memory for very large files)
    let rows = [];          // raw row objects
    let headerMap = {};      // canonical alias -> actual header name
    let activityIdCol = null; // key in row objects
    let durationCol = null;
    let totalFloatCol = null;
    let predCol = null;
    let nameCol = null;

    // UI refs
    const xlsxInput = document.getElementById('xlsxInput');
    const loadBtn = document.getElementById('loadBtn');
    const progressEl = document.getElementById('progress');
    const mappingSection = document.getElementById('mappingSection');
    const colMap = document.getElementById('colMap');
    const startSelect = document.getElementById('startActivity');
    const manualStart = document.getElementById('manualStart');
    const applyManualStart = document.getElementById('applyManualStart');
    const traceBtn = document.getElementById('traceBtn');
    const exportBtn = document.getElementById('exportBtn');
    const resultsSection = document.getElementById('resultsSection');
    const resultsBody = document.getElementById('resultsBody');

    // Progress tracking
    let totalRows = 0;
    let parsedRows = 0;
    let lastProgressPct = -1;

    const FINAL_ANCHOR = "dpfg8620";

    xlsxInput.addEventListener('change', () => {
      loadBtn.disabled = !xlsxInput.files.length;
    });

    loadBtn.addEventListener('click', async () => {
      if (!xlsxInput.files?.length) return;
      const file = xlsxInput.files[0];
      try {
        resetUIForParse();
        progressEl.classList.remove('hidden');
        progressEl.textContent = 'Reading workbook...';
        const wb = await readWorkbook(file);

        progressEl.textContent = 'Parsing sheet data (this may take a moment)...';
        const sheetName = Object.keys(wb.Sheets)[0];
        const sheet = wb.Sheets[sheetName];

        // Use streaming-safe parsing if available (SheetJS returns full JSON; we emulate streaming by chunking)
        const full = XLSX.utils.sheet_to_json(sheet, { defval: "" });
        totalRows = full.length;
        rows = [];

        // Process in batches to keep UI responsive
        const BATCH = 2000; // adjust batch size to balance responsiveness
        let idx = 0;

        function processBatch() {
          const end = Math.min(idx + BATCH, totalRows);
          // Push batch
          for (; idx < end; idx++) {
            rows.push(full[idx]);
          }
          parsedRows = rows.length;
          const pct = Math.floor((parsedRows / totalRows) * 100);
          if (pct !== lastProgressPct) {
            progressEl.textContent = `Parsing: ${pct}% (${parsedRows}/${totalRows})`;
            lastProgressPct = pct;
          }
          if (idx < totalRows) {
            // Schedule next batch
            requestAnimationFrame(processBatch);
          } else {
            // All done
            progressEl.textContent = 'Detecting headers...';
            detectHeadersAndMap(rows);
            populateStartDropdown();
            mappingSection.style.display = 'block';
            resultsSection.style.display = 'none';
            exportBtn.disabled = true;
            progressEl.classList.add('hidden');
          }
        }

        processBatch(); // kick off
      } catch (err) {
        progressEl.classList.add('hidden');
        alert('Error parsing file: ' + err.message);
      }
    });

    traceBtn.addEventListener('click', () => {
      const manual = (manualStart.value || "").trim();
      const chosenFromDropdown = startSelect.value;
      const startId = manual || chosenFromDropdown;
      if (!startId) {
        alert('Please specify a Start Activity ID (via dropdown or manual input).');
        return;
      }

      // Compute paths (potentially heavy). We chunk if needed.
      const prep = computePaths(rows, headerMap);
      const { paths, activities, graphP, graphS } = prep;
      if (!paths || paths.length === 0) {
        alert('No backward paths found from the chosen start.');
        return;
      }

      const results = traceFrom(startId, paths, activities, graphP, graphS);
      displayResults(results);
      exportBtn.disabled = !(results && results.length > 0);
    });

    exportBtn.addEventListener('click', () => {
      // Build a CSV from current results
      const rowsEl = resultsBody.querySelectorAll('tr');
      if (!rowsEl || rowsEl.length === 0) {
        alert('No results to export.');
        return;
      }
      const header = ['Path Score','Path IDs','Path Names','Node Count'];
      const csvRows = [header];
      rowsEl.forEach(tr => {
        const tds = tr.querySelectorAll('td');
        csvRows.push([
          tds[0]?.innerText,
          tds[1]?.innerText,
          tds[2]?.innerText,
          tds[3]?.innerText
        ]);
      });
      const csvContent = csvRows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'Top10_Backward_Critical_Paths.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    applyManualStart.addEventListener('click', () => {
      if (manualStart.value.trim()) {
        // Optional UX hint
        alert('Manual Start ID set. Press "Trace Backward Paths" to run.');
      } else {
        alert('Enter a Start Activity ID in the text field first.');
      }
    });

    // Helpers: reading workbook
    function readWorkbook(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => {
          const data = new Uint8Array(e.target.result);
          const wb = XLSX.read(data, { type: 'array' });
          resolve(wb);
        };
        reader.onerror = () => reject(new Error('Failed to read file.'));
        reader.readAsArrayBuffer(file);
      });
    }

    // Reset UI state for fresh parse
    function resetUIForParse() {
      rows = [];
      totalRows = 0;
      parsedRows = 0;
      lastProgressPct = -1;
      headerMap = {};
      activityIdCol = null; durationCol = null;
      totalFloatCol = null; predCol = null; nameCol = null;

      // Hide sections until ready
      mappingSection.style.display = 'none';
      resultsSection.style.display = 'none';
      resultsBody.innerHTML = '';
      colMap.innerHTML = '';
      startSelect.innerHTML = '';
      manualStart.value = '';
      exportBtn.disabled = true;
    }

    // Detect headers robustly and map to canonical columns
    function detectHeadersAndMap(rows) {
      const first = rows[0];
      const headers = Object.keys(first);
      const normToActual = {};
      headers.forEach(h => {
        normToActual[normalizeHeader(h)] = h;
      });

      function findCol(variants) {
        for (const v of variants) {
          const key = normalizeHeader(v);
          if (normToActual[key] !== undefined) return normToActual[key];
        }
        return null;
      }

      // Variants chosen to be permissive
      activityIdCol = findCol(['Activity ID','Activity_Id','Task ID','WBS']);
      durationCol = findCol(['At Completion Duration','Duration','Duration (hrs)']);
      totalFloatCol = findCol(['Total Float','Total_Float','Float','Float Time']);
      predCol = findCol(['Predecessors','Predecessor Details','Predecessor_Details']);
      nameCol = findCol(['Activity Name','Task Name','Name']) || activityIdCol;

      headerMap = {
        'Activity ID': activityIdCol,
        'At Completion Duration': durationCol,
        'Total Float': totalFloatCol,
        'Predecessors': predCol,
        'Activity Name': nameCol
      };

      // Render detected mapping
      colMap.innerHTML = '';
      Object.entries(headerMap).forEach(([key, val]) => {
        const li = document.createElement('li');
        li.textContent = `${key}: ${val || '(not found)'}`;
        colMap.appendChild(li);
      });
    }

    // Populate start dropdown from IDs
    function populateStartDropdown() {
      startSelect.innerHTML = '';
      const ids = new Set(rows.map(r => r[activityIdCol]).filter(Boolean));
      ids.forEach(id => {
        const opt = document.createElement('option');
        opt.value = id;
        opt.text = id;
        startSelect.appendChild(opt);
      });
      if (ids.has(FINAL_ANCHOR)) startSelect.value = FINAL_ANCHOR;
    }

    // Compute graphs and path data
    function computePaths(allRows, headers) {
      // Build maps: id -> row
      const rowsById = {};
      for (let i = 0; i < allRows.length; i++) {
        const r = allRows[i];
        const id = r[activityIdCol];
        if (id) rowsById[id] = r;
      }

      // Graphs: predecessors and successors
      const graphP = {};
      const graphS = {};

      // Predecessors per row
      for (let i = 0; i < allRows.length; i++) {
        const r = allRows[i];
        const a = r[activityIdCol];
        const predsRaw = (r[predCol] || "").toString().trim();
        const predsList = predsRaw ? predsRaw.split(',').map(x => x.trim()).filter(x => x.length) : [];
        graphP[a] = predsList;
        predsList.forEach(p => {
          if (!graphS[p]) graphS[p] = [];
          graphS[p].push(a);
        });
      }

      // Activities meta
      const activities = {};
      for (let i = 0; i < allRows.length; i++) {
        const r = allRows[i];
        const id = r[activityIdCol];
        if (!id) continue;
        activities[id] = {
          id,
          name: r[nameCol] || id,
          duration: parseFloat(r[durationCol] || 0) || 0,
          totalFloat: parseFloat(r[totalFloatCol] || 0) || 0
        };
      }

      const paths = findBackwardPaths(FINAL_ANCHOR, graphP);
      return { paths, activities, graphP, graphS };
    }

    // DFS to collect backward paths ending at finalNode
    function findBackwardPaths(finalNode, graph) {
      const paths = [];
      const stack = [[finalNode, [finalNode]]];
      // Iterative DFS to avoid call-stack blow for deep graphs
      while (stack.length) {
        const [node, path] = stack.pop();
        const preds = graph[node] || [];
        if (preds.length === 0) {
          paths.push(path.slice());
          continue;
        }
        for (const p of preds) {
          if (path.includes(p)) continue; // cycle guard
          const newPath = path.concat(p);
          stack.push([p, newPath]);
        }
      }
      // Convert to start->end order
      return paths.map(p => p.slice().reverse());
    }

    // Trace paths from chosen start
    function traceFrom(startId, paths, activities, graphP, graphS) {
      const tFloat = {};
      Object.values(activities).forEach(a => { tFloat[a.id] = a.totalFloat || 0; });

      const valid = paths.filter(p => p.includes(startId));
      const scored = valid.map(path => {
        const score = path.reduce((acc, nid) => acc + (tFloat[nid] || 0), 0);
        const pathIds = path.join(' -> ');
        const pathNames = path.map(nid => activities[nid]?.name ?? nid).join(' -> ');
        return { score, pathIds, pathNames, nodeCount: path.length };
      });

      scored.sort((a, b) => a.score - b.score);
      return scored.slice(0, 10);
    }

    function displayResults(results) {
      resultsSection.style.display = 'block';
      resultsBody.innerHTML = '';
      results.forEach(r => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${r.score.toFixed(2)}</td>
          <td>${r.pathIds}</td>
          <td>${r.pathNames}</td>
          <td>${r.nodeCount}</td>
        `;
        resultsBody.appendChild(tr);
      });
    }
  </script>
</body>
</html>
