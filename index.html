<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Critical Path Finder — CSV Only (Full Depth, Free Float)</title>
<style>
  :root {
    --bg: #ffffff; --fg: #111; --muted: #666;
    --panel: #f6f8fa; --border: #e1e4e8; --accent: #0b5fff;
  }
  body { font-family: Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; color: var(--fg); background: var(--bg); }
  h1 { margin-top: 0; }
  .row { margin: 0.75rem 0; }
  input[type="text"], select { padding: 0.45rem; }
  input[type="text"] { width: 360px; }
  button { padding: 0.5rem 0.9rem; margin-right: 0.5rem; cursor: pointer; }
  #log { white-space: pre-wrap; background: var(--panel); border: 1px solid var(--border); padding: 0.75rem; border-radius: 6px; min-height: 8rem; }
  .muted { color: var(--muted); font-size: 0.9rem; }
  .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 0.75rem; }
  label { font-weight: 600; display: block; margin-bottom: 0.25rem; }
  .small { font-size: 0.9rem; }
</style>
</head>
<body>
  <h1>Critical Path Finder — CSV Only (Full Depth, Free Float)</h1>

  <div class="row controls">
    <div>
      <label for="fileInput">CSV File (.csv)</label>
      <input id="fileInput" type="file" accept=".csv" />
      <div class="muted small">Runs entirely in your browser (offline).</div>
    </div>

    <div>
      <label for="startId">Starting Activity ID</label>
      <input id="startId" type="text" placeholder="Enter an Activity ID from the CSV" />
    </div>

    <div>
      <label for="unitSelect">Time Unit for FF & Lags</label>
      <select id="unitSelect">
        <option value="days" selected>Days</option>
        <option value="hours">Hours</option>
      </select>
      <div class="muted small">Lag strings with explicit units (e.g., +8h) are respected.</div>
    </div>

    <div>
      <label for="dateLocale">Date Format (Start/Finish)</label>
      <select id="dateLocale">
        <option value="us" selected>US — MM/DD/YYYY [HH:MM]</option>
        <option value="intl">Intl — DD/MM/YYYY [HH:MM]</option>
        <option value="auto">Auto (try multiple patterns)</option>
      </select>
      <div class="muted small">Also supports 05-Jan-2025 08:00, etc.</div>
    </div>
  </div>

  <div class="row">
    <button id="runBtn">Run Analysis</button>
    <button id="resetBtn">Reset</button>
    <button id="downloadBtn" disabled>Download Top‑10 Paths (CSV)</button>
  </div>

  <div class="row">
    <strong>Notes</strong>
    <ul class="small">
      <li>Traverses <em>all</em> predecessors recursively, cycle‑safe.</li>
      <li>Per‑edge Free Float is computed from <code>Start</code>/<code>Finish</code> and relationship + lag from <code>Predecessor Details</code>. If only <code>Predecessors</code> is present, edges default to <code>FS + 0</code>.</li>
      <li>Top‑10 paths are ranked by the sum of per‑edge Free Float (lowest totals first).</li>
      <li>Export CSV puts one path per row, with all Activity IDs on that path (from the activity of interest backward).</li>
    </ul>
  </div>

  <h3>Log</h3>
  <div id="log">Load a CSV, enter a Starting Activity ID, configure options, then click “Run Analysis”.</div>

<script>
/* ========================== CSV Parsing ========================== */
function parseCSV(text, delimiter = ",") {
  const rows = [];
  let row = [], val = "", inQuotes = false;
  for (let i = 0; i < text.length; i++) {
    const c = text[i], n = text[i+1];
    if (inQuotes) {
      if (c === '"') { if (n === '"') { val += '"'; i++; } else { inQuotes = false; } }
      else { val += c; }
    } else {
      if (c === '"') inQuotes = true;
      else if (c === delimiter) { row.push(val); val = ""; }
      else if (c === "\r") { /* ignore */ }
      else if (c === "\n") { row.push(val); rows.push(row); row = []; val = ""; }
      else { val += c; }
    }
  }
  row.push(val); rows.push(row);
  if (rows.length && rows[rows.length-1].length === 1 && rows[rows.length-1][0] === "") rows.pop();
  return rows;
}
function rowsToObjects(rows) {
  if (!rows || rows.length === 0) return { headersRaw: [], headersKey: [], records: [] };
  const headersRaw = rows[0].map(h => (h ?? "").toString().trim());
  const headersKey = headersRaw.map(h => h.toLowerCase());
  const records = [];
  for (let r = 1; r < rows.length; r++) {
    const obj = {};
    for (let c = 0; c < headersRaw.length; c++) {
      const k = headersRaw[c];
      obj[k] = (rows[r][c] ?? "").toString();
      obj["__" + k.toLowerCase()] = (rows[r][c] ?? "").toString();
    }
    records.push(obj);
  }
  return { headersRaw, headersKey, records };
}
function resolveColumn(headersKey, headersRaw, candidates) {
  for (const cand of candidates) {
    const idx = headersKey.indexOf(cand.toLowerCase());
    if (idx !== -1) return headersRaw[idx];
  }
  return null;
}

/* ========================== Date Parsing ========================== */
function parseDateFlexible(s, localePref = "us") {
  if (!s) return null;
  const str = s.trim();
  if (!str) return null;

  const t = Date.parse(str);
  if (!Number.isNaN(t)) return new Date(t);

  const slashRe = /^(\d{1,2})\/\-\/\-(?: T:(\d{2})(?::(\d{2}))?)?$/;
  const mSlash = slashRe.exec(str);
  if (mSlash) {
    let a = +mSlash[1], b = +mSlash[2], y = +mSlash[3]; if (y < 100) y += 2000;
    let M, D; if (localePref === "intl") { D = a; M = b; } else { M = a; D = b; }
    const hh = +(mSlash[4]||0), mm = +(mSlash[5]||0), ss = +(mSlash[6]||0);
    return new Date(y, M-1, D, hh, mm, ss);
  }

  const monMap = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11};
  const dashMon = /^(\d{1,2})- - (?: T:(\d{2})(?::(\d{2}))?)?$/;
  const mDash = dashMon.exec(str);
  if (mDash) {
    const D = +mDash[1], mon = monMap[mDash[2].toLowerCase()];
    if (mon != null) {
      let y = +mDash[3]; if (y < 100) y += 2000;
      const hh = +(mDash[4]||0), mm = +(mDash[5]||0), ss = +(mDash[6]||0);
      return new Date(y, mon, D, hh, mm, ss);
    }
  }

  if (localePref === "auto") return parseDateFlexible(str, "us") || parseDateFlexible(str, "intl");
  return null;
}

/* ====================== Relationship & Lag Parsing ====================== */
function parsePredDetails(detailsStr) {
  // Accepts: "A100 FS+2d; A200 SS-8h", "B10", "C30FF-1d"
  if (!detailsStr) return [];
  const items = detailsStr.split(/[,;\n]+/).map(x => x.trim()).filter(Boolean);
  const out = [];
  for (const it of items) {
    const idMatch = it.match(/^[^\s()]+/);
    const predId = idMatch ? idMatch[0].trim() : it;

    const relMatch = it.match(/\b(FS|SS|FF|SF)\b/i);
    const type = relMatch ? relMatch[1].toUpperCase() : "FS";

    const lagMatch = it.match(/([+-]\s*\d*\.?\d*\s*(?:d|h|m)?)/i);
    let lagVal = 0, lagUnitRaw = null;
    if (lagMatch) {
      const raw = lagMatch[1].replace(/\s+/g,"");
      const unitM = raw.match(/[dhm]$/i);
      lagUnitRaw = unitM ? unitM[0].toLowerCase() : null;
      const num = raw.replace(/[dhm]/ig,"");
      const parsed = parseFloat(num);
      lagVal = Number.isNaN(parsed) ? 0 : parsed;
    }
    out.push({ predId, type, lagVal, lagUnitRaw });
  }
  return out;
}
function parsePredecessorIDs(simpleStr) {
  if (!simpleStr) return [];
  return simpleStr.split(/[,;]+/).map(s => (s || "").trim()).filter(Boolean).map(id => ({
    predId: id, type: "FS", lagVal: 0, lagUnitRaw: null
  }));
}

/* ============================= Model Build ============================= */
function buildModel(csvObj, opts) {
  const { headersRaw, headersKey, records } = csvObj;
  const idCol     = resolveColumn(headersKey, headersRaw, ["Activity ID"]);
  const startCol  = resolveColumn(headersKey, headersRaw, ["Start"]);
  const finishCol = resolveColumn(headersKey, headersRaw, ["Finish"]);
  const predDetailsCol = resolveColumn(headersKey, headersRaw, ["Predecessor Details"]);
  const predsCol       = resolveColumn(headersKey, headersRaw, ["Predecessors"]);

  if (!idCol)     throw new Error('Required column "Activity ID" not found.');
  if (!startCol)  throw new Error('Required column "Start" not found.');
  if (!finishCol) throw new Error('Required column "Finish" not found.');
  if (!predDetailsCol && !predsCol) {
    throw new Error('Required column "Predecessor Details" or "Predecessors" not found.');
  }

  const nodes = new Map(); // id -> { id, ES, EF, startStr, finishStr }
  for (const r of records) {
    const id = (r[idCol] ?? "").trim();
    if (!id) continue;
    const ES = parseDateFlexible(r[startCol], opts.dateLocale);
    const EF = parseDateFlexible(r[finishCol], opts.dateLocale);
    nodes.set(id, { id, ES, EF, startStr: r[startCol] ?? "", finishStr: r[finishCol] ?? "" });
  }

  const predMap = new Map(); // succId -> [{ predId, type, lagVal, lagUnitRaw }]
  for (const r of records) {
    const succId = (r[idCol] ?? "").trim();
    if (!succId) continue;
    let arr = [];
    if (predDetailsCol && r[predDetailsCol]) {
      arr = parsePredDetails(r[predDetailsCol]);
    } else if (predsCol && r[predsCol]) {
      arr = parsePredecessorIDs(r[predsCol]);
    }
    arr = arr.filter(x => !!x.predId);
    if (arr.length) predMap.set(succId, arr);
  }

  return { nodes, predMap, idCol, startCol, finishCol };
}

/* ========================= Free Float Computation ========================= */
function unitToMs(unitSel) { return unitSel === "hours" ? 3600000 : 86400000; }
function lagToMs(lagVal, lagUnitRaw, unitSel) {
  if (!lagVal) return 0;
  if (!lagUnitRaw) return lagVal * unitToMs(unitSel);
  switch (lagUnitRaw) {
    case "d": return lagVal * 86400000;
    case "h": return lagVal * 3600000;
    case "m": return lagVal * 60000;
    default:  return lagVal * unitToMs(unitSel);
  }
}
function edgeFreeFloat(predNode, succNode, relType, lagVal, lagUnitRaw, unitSel) {
  const oneUnitMs = unitToMs(unitSel);
  const lagMs = lagToMs(lagVal, lagUnitRaw, unitSel);

  const ES_P = predNode?.ES || null;
  const EF_P = predNode?.EF || null;
  const ES_S = succNode?.ES || null;
  const EF_S = succNode?.EF || null;

  let base = null, target = null;
  switch ((relType || "FS").toUpperCase()) {
    case "SS": base = ES_P; target = ES_S; break;
    case "FF": base = EF_P; target = EF_S; break;
    case "SF": base = ES_P; target = EF_S; break;
    case "FS":
    default:   base = EF_P; target = ES_S; break;
  }

  if (!base || !target) return { ffUnits: 0, ms: 0, missingDates: true };

  const ms = target.getTime() - (base.getTime() + lagMs);
  return { ffUnits: ms / oneUnitMs, ms, missingDates: false };
}

/* =============================== DFS / Paths =============================== */
/*
  We do a full-depth DFS that collects:
  - nodesOnPath: [Succ, Pred1, Pred2, ... leafPred]
  - edgesOnPath: [{succId, predId, type, lag, ffUnits, flags}, ...] aligned with transitions
  We stop ONLY at: (a) no predecessors recorded for current node, or (b) cycle detection.
*/
function enumeratePaths(model, startId, unitSel, maxPaths = 200000) {
  const { nodes, predMap } = model;
  if (!nodes.has(startId)) throw new Error(`Starting Activity ID "${startId}" not found in file.`);

  const results = [];                     // { nodes: [ids], edges: [...], score }
  const nodesOnPath = [startId];          // start with the activity of interest
  const edgesOnPath = [];                 // per-edge info aligned with transitions

  const onStack = new Set([startId]);     // cycle detection within current path

  function dfs(currSuccId) {
    if (results.length >= maxPaths) return;

    const preds = predMap.get(currSuccId) || [];
    if (preds.length === 0) {
      // Leaf reached — compute score and record
      const score = edgesOnPath.reduce((acc, e) => acc + (Number(e.ffUnits) || 0), 0);
      results.push({ nodes: [...nodesOnPath], edges: [...edgesOnPath], score });
      return;
    }

    for (const rel of preds) {
      const predId = rel.predId;
      const type = (rel.type || "FS").toUpperCase();
      const predNode = nodes.get(predId) || null;
      const succNode = nodes.get(currSuccId) || null;
      const ff = edgeFreeFloat(predNode, succNode, type, rel.lagVal || 0, rel.lagUnitRaw || null, unitSel);

      // Add this transition (currSuccId <- predId)
      edgesOnPath.push({
        succId: currSuccId, predId, type,
        lagVal: rel.lagVal || 0, lagUnitRaw: rel.lagUnitRaw || null,
        ffUnits: ff.ffUnits, flags: { missingDates: ff.missingDates, unknownPred: !predNode }
      });

      // Extend node sequence
      nodesOnPath.push(predId);

      if (onStack.has(predId)) {
        // Cycle detected — close out a partial path
        const score = edgesOnPath.reduce((acc, e) => acc + (Number(e.ffUnits) || 0), 0);
        results.push({ nodes: [...nodesOnPath, "(cycle)"], edges: [...edgesOnPath], score, cycle: true });
      } else {
        onStack.add(predId);
        dfs(predId);
        onStack.delete(predId);
      }

      // Backtrack
      nodesOnPath.pop();
      edgesOnPath.pop();

      if (results.length >= maxPaths) break;
    }
  }

  dfs(startId);
  return results;
}

/* ============================ Ranking & Export ============================ */
function rankPathsByFF(paths) {
  return paths
    .map((p, idx) => ({ ...p, idx }))
    .sort((a, b) => a.score - b.score)
    .slice(0, 10);
}

/* Build a single CSV where each row is one path, with all IDs in columns. */
function buildPathsCSV(topPaths, unitSel) {
  const u = unitSel === "hours" ? "h" : "d";
  const maxLen = topPaths.reduce((m, p) => Math.max(m, p.nodes.length), 0);

  // Header: Path, Rank, NodeCount, TotalFF, PathString, Node_1..Node_N
  const header = ["Path","Rank","NodeCount",`Total FF (${u})`,"Path String"];
  for (let i = 1; i <= maxLen; i++) header.push(`Node_${i}`);

  const rows = [header];

  topPaths.forEach((p, i) => {
    const pathString = p.nodes.join(" <- "); // S <- P1 <- P2 ...
    const base = [`Path_${i+1}`, i+1, p.nodes.length, p.score.toFixed(4), pathString];
    const nodeCols = Array.from({ length: maxLen }, (_, k) => p.nodes[k] ?? "");
    rows.push([...base, ...nodeCols]);
  });

  return rows;
}

/* Also provide a detailed CSV with per-edge FF (optional, downloadable via console). */
function buildEdgesCSV(topPaths, unitSel) {
  const u = unitSel === "hours" ? "h" : "d";
  const rows = [[
    "Path","Rank","Order","Successor ID","Predecessor ID","Rel Type","Lag (raw)",
    `Edge FF (${u})`,"Cumulative FF","MissingDates","UnknownPred"
  ]];

  topPaths.forEach((p, i) => {
    let cum = 0;
    p.edges.forEach((e, k) => {
      const ff = Number(e.ffUnits) || 0;
      cum += ff;
      rows.push([
        `Path_${i+1}`, i+1, k+1,
        e.succId, e.predId, e.type,
        (e.lagVal ? (e.lagVal + (e.lagUnitRaw || u)) : "0"),
        ff.toFixed(4), cum.toFixed(4),
        e.flags.missingDates ? "Y" : "",
        e.flags.unknownPred ? "Y" : ""
      ]);
    });
  });

  return rows;
}

function toCSV(rows) {
  const esc = v => {
    const s = (v ?? "").toString();
    return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
  };
  return rows.map(r => r.map(esc).join(",")).join("\n");
}
function downloadCSV(filename, text) {
  const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement("a"), { href: url, download: filename });
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
}

/* ================================ UI Logic ================================ */
const fileInput   = document.getElementById("fileInput");
const startIdInput= document.getElementById("startId");
const unitSelect  = document.getElementById("unitSelect");
const dateLocale  = document.getElementById("dateLocale");
const runBtn      = document.getElementById("runBtn");
const resetBtn    = document.getElementById("resetBtn");
const downloadBtn = document.getElementById("downloadBtn");
const logEl       = document.getElementById("log");

let lastTopPaths = null;
let lastUnitSel = "days";

function log(msg) { logEl.textContent = msg; }

runBtn.addEventListener("click", () => {
  const file = fileInput.files && fileInput.files[0];
  if (!file) return log("Please choose a .csv file first.");
  const startId = (startIdInput.value || "").trim();
  if (!startId) return log("Please enter a Starting Activity ID.");

  const unitSel = unitSelect.value;
  const localeSel = dateLocale.value;

  const reader = new FileReader();
  reader.onerror = () => log("Failed to read the CSV. Please try again.");
  reader.onload = () => {
    try {
      const text = reader.result.toString();
      const rows = parseCSV(text, ",");
      const csvObj = rowsToObjects(rows);
      const model = buildModel(csvObj, { dateLocale: localeSel });

      // Enumerate all paths (full depth), then rank by total FF
      const allPaths = enumeratePaths(model, startId, unitSel, 200000);
      if (allPaths.length === 0) {
        log(`No predecessor paths found starting from "${startId}".`);
        lastTopPaths = null; downloadBtn.disabled = true; return;
      }

      const topPaths = rankPathsByFF(allPaths);
      lastTopPaths = topPaths;
      lastUnitSel = unitSel;

      // Preview (Top‑10)
      const u = unitSel === "hours" ? "h" : "d";
      let preview = `Found ${allPaths.length} total path(s). Showing Top ${topPaths.length} by lowest total Free Float:\n\n`;
      topPaths.forEach((p, i) => {
        preview += `#${i+1}  Total FF=${p.score.toFixed(2)}${u}  Path: ${p.nodes.join(" <- ")}\n`;
      });
      log(preview);
      downloadBtn.disabled = false;

      // (Optional) If you also want the per-edge CSV, uncomment to auto‑download a second file:
      // const edgesCSV = toCSV(buildEdgesCSV(topPaths, unitSel));
      // downloadCSV("critical_paths_edges.csv", edgesCSV);

    } catch (e) {
      console.error(e);
      log("Error: " + (e && e.message ? e.message : e));
      lastTopPaths = null; downloadBtn.disabled = true;
    }
  };
  reader.readAsText(file, "utf-8");
});

downloadBtn.addEventListener("click", () => {
  if (!lastTopPaths) return;
  const rows = buildPathsCSV(lastTopPaths, lastUnitSel);
  downloadCSV("critical_paths_top10_paths.csv", toCSV(rows));
});

resetBtn.addEventListener("click", () => {
  fileInput.value = "";
  startIdInput.value = "";
  lastTopPaths = null;
  downloadBtn.disabled = true;
  log("Load a CSV, enter a Starting Activity ID, configure options, then click “Run Analysis”.");
});
</script>
</body>
</html>
