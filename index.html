[full HTML content here]
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CPM Backward Path Analyzer</title>
<style>
/* 
  Inline CSS for responsive layout, dark/light theme, and basic styling.
  We store everything here to ensure a single-file offline SPA. 
  Keep it minimal but production-grade, with some responsiveness. 
*/
:root {
  --bg-color-light: #f9f9f9;
  --text-color-light: #333;
  --bg-color-dark: #121212;
  --text-color-dark: #e5e5e5;
  --accent-color: #007acc;
  --transition-speed: 0.2s;
  --header-height: 50px;
  --sidebar-width: 280px;
  --content-max-width: 1200px;
}

/* Light theme as default */
body.light {
  background-color: var(--bg-color-light);
  color: var(--text-color-light);
}

/* Dark theme overrides */
body.dark {
  background-color: var(--bg-color-dark);
  color: var(--text-color-dark);
}

body {
  margin: 0;
  padding: 0;
  font-family: sans-serif;
  transition: background-color var(--transition-speed), color var(--transition-speed);
}

header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: var(--header-height);
  padding: 0 1rem;
  background-color: var(--accent-color);
  color: white;
}

header .left-area {
  display: flex;
  align-items: center;
}

header .app-title {
  font-weight: bold;
  margin-right: 1rem;
}

header button {
  margin-left: 0.5rem;
}

main {
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: 1rem;
  max-width: var(--content-max-width);
  margin: 0 auto;
  padding: 1rem;
}

@media (max-width: 1024px) {
  main {
    grid-template-columns: 1fr;
  }
}

.left-panel, .right-panel {
  background-color: rgba(0,0,0,0.03);
  padding: 0.5rem;
  border-radius: 4px;
}

.left-panel h2, .right-panel h2 {
  margin-top: 0;
}

.footer-area {
  padding: 1rem;
  text-align: center;
  font-size: 0.9rem;
  background-color: rgba(0,0,0,0.05);
}

section.settings-panel {
  position: fixed;
  top: var(--header-height);
  right: 0;
  width: var(--sidebar-width);
  bottom: 0;
  background-color: rgba(0,0,0,0.8);
  color: white;
  transform: translateX(100%);
  transition: transform var(--transition-speed);
  padding: 1rem;
  overflow-y: auto;
  z-index: 999;
}

section.settings-panel.open {
  transform: translateX(0);
}

section.help-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 400px;
  max-width: 90%;
  background-color: #fff;
  padding: 1rem;
  border-radius: 4px;
  transform: translate(-50%,-50%) scale(0);
  opacity: 0;
  transition: transform var(--transition-speed), opacity var(--transition-speed);
  z-index: 9999;
}
section.help-modal.open {
  transform: translate(-50%,-50%) scale(1);
  opacity: 1;
}
.help-modal h3 {
  margin-top: 0;
}

div.log-panel {
  border: 1px solid #ccc;
  background: #fff;
  color: #000;
  height: 150px;
  overflow-y: auto;
  margin-top: 0.5rem;
  padding: 0.25rem;
  display: none;
}
div.log-panel.open {
  display: block;
}

.top-cards {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}
.top-cards .card {
  background-color: #fff;
  color: #000;
  padding: 0.5rem;
  flex: 1;
  border-radius: 4px;
  border: 1px solid #ccc;
}
table {
  width: 100%;
  border-collapse: collapse;
}
table thead {
  background: #ddd;
}
table th, table td {
  border: 1px solid #ccc;
  padding: 0.25rem;
  text-align: left;
  word-break: break-all;
}
.acceptance-checklist {
  text-align: left;
  display: inline-block;
  margin-bottom: 1rem;
}
.hidden {
  display: none !important;
}
.progress-bar-area {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
label[for="csvFile"] {
  cursor: pointer;
  color: var(--accent-color);
  text-decoration: underline;
}
.drag-drop-area {
  border: 2px dashed #aaa;
  padding: 1rem;
  text-align: center;
  margin-bottom: 1rem;
}
.drag-drop-area.dragover {
  border-color: var(--accent-color);
}
</style>
</head>
<body class="light">
<header>
  <div class="left-area">
    <div class="app-title">CPM Backward Path Analyzer</div>
    <button id="themeToggleBtn" title="Toggle Theme (t)">Light/Dark</button>
  </div>
  <div class="right-area">
    <button id="helpBtn" title="Help (?)">Help</button>
    <button id="settingsBtn" title="Settings">Settings</button>
  </div>
</header>

<main>
  <div class="left-panel">
    <h2>Controls</h2>
    <div class="csv-input-section">
      <h3>CSV Input</h3>
      <div class="drag-drop-area" id="dragDropArea">Drop CSV file here or click to select.</div>
      <input type="file" id="csvFile" accept=".csv" style="display:none">
      <button id="loadSampleBtn">Load Sample</button>
      <div id="csvRowCount"></div>
    </div>
    <hr>
    <h3>Parameters</h3>
    <label for="unitToggle">Units:</label>
    <select id="unitToggle">
      <option value="days">Days</option>
      <option value="hours">Hours</option>
    </select>
    <br>
    <label for="hoursPerDay">Hours/Day:</label>
    <input type="number" id="hoursPerDay" value="8.00" step="0.25" min="1" max="24">
    <br>
    <label for="fallbackMode">Fallback Mode:</label>
    <select id="fallbackMode">
      <option value="strict">Strict</option>
      <option value="placeholder">Placeholder</option>
    </select>
    <br>
    <label for="maxPaths">Max Paths:</label>
    <input type="number" id="maxPaths" value="250" min="1" max="100000">
    <br>
    <label for="maxDepth">Max Depth:</label>
    <input type="number" id="maxDepth" value="500" min="10" max="10000">
    <hr>
    <h3>Analysis</h3>
    <label for="startActivityId">Start Activity ID:</label>
    <input type="text" id="startActivityId" list="activitiesList">
    <datalist id="activitiesList"></datalist>
    <br>
    <div class="progress-bar-area">
      <progress id="globalProgress" value="0" max="100" style="width:80%;"></progress>
      <span id="progressLabel"></span>
    </div>
    <button id="buildGraphBtn" title="(g)">Build Graph</button>
    <button id="analyzePathsBtn" title="(a)">Analyze Paths</button>
    <button id="cancelBtn" class="hidden">Cancel/Stop</button>
    <button id="resetBtn">Reset</button>
    <hr>
    <h3>Exports</h3>
    <button id="exportBtn" title="(e)">Export</button>
    <br>
    <button id="logToggleBtn" title="(l)">Toggle Log</button>
    <button id="selfTestBtn">Run Self-Test</button>
    <hr>
    <div id="statusBadges">
      <div><strong>State:</strong> <span id="appStateLabel">Idle</span></div>
      <div id="stateDetails"></div>
    </div>
  </div>

  <div class="right-panel">
    <div class="top-cards">
      <div class="card">
        <div>Activities:</div>
        <div id="activityCount">0</div>
      </div>
      <div class="card">
        <div>Edges:</div>
        <div id="edgeCount">0</div>
      </div>
      <div class="card">
        <div>Cycle Detected:</div>
        <div id="cycleDetected">No</div>
      </div>
      <div class="card">
        <div>Project Finish (Days):</div>
        <div id="projectFinish">---</div>
      </div>
      <div class="card">
        <div>Analysis Time (ms):</div>
        <div id="analysisTime">0</div>
      </div>
    </div>
    <h3>Top 3 Paths Preview</h3>
    <table id="top3Table">
      <thead>
        <tr>
          <th>Rank</th>
          <th>Total FF</th>
          <th>Edges</th>
          <th>Bottleneck</th>
          <th>Terminal Completed ID</th>
          <th>Path</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <h3>Detailed Paths</h3>
    <table id="detailedPathsTable">
      <thead>
        <tr>
          <th>Rank</th>
          <th>TotalFF</th>
          <th>Edges</th>
          <th>BottleneckFF</th>
          <th>TerminalID</th>
          <th>PathIDs</th>
          <th>PerEdgeFF</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <h4>Log Panel</h4>
    <div class="log-panel" id="logPanel"></div>
  </div>
</main>

<footer class="footer-area">
  <div class="acceptance-checklist">
    <h4>Acceptance Checklist</h4>
    <ul>
      <li><label><input type="checkbox" id="chkCsvParsed"> CSV parsed</label></li>
      <li><label><input type="checkbox" id="chkGraphBuilt"> Graph built</label></li>
      <li><label><input type="checkbox" id="chkNoCycles"> No cycles detected</label></li>
      <li><label><input type="checkbox" id="chkCpmTimes"> CPM times computed</label></li>
      <li><label><input type="checkbox" id="chkFreeFloat"> Free float computed</label></li>
      <li><label><input type="checkbox" id="chkPathsFound"> Backward paths enumerated</label></li>
      <li><label><input type="checkbox" id="chkPathsRanked"> Paths ranked, Top 3 displayed</label></li>
      <li><label><input type="checkbox" id="chkExportReady"> Output files generated</label></li>
      <li><label><input type="checkbox" id="chkLogAvailable"> Log available</label></li>
      <li><label><input type="checkbox" id="chkUnitToggle"> Unit toggle updates</label></li>
    </ul>
  </div>
  <div>Build info: v1.0.1 - 2023-10-09</div>
</footer>

<section class="settings-panel" id="settingsPanel" aria-label="Settings Panel">
  <h2>Settings</h2>
  <p>Change fallback mode, adjust max paths and depth, etc.</p>
  <button id="closeSettingsBtn">Close</button>
</section>

<section class="help-modal" id="helpModal" aria-label="Help Modal">
  <h3>Help & Instructions</h3>
  <p>Keyboard Shortcuts:</p>
  <ul>
    <li>? : Show help</li>
    <li>t : Toggle Theme</li>
    <li>g : Build Graph</li>
    <li>a : Analyze Paths</li>
    <li>e : Export</li>
    <li>l : Toggle Log</li>
  </ul>
  <button id="closeHelpBtn">Close</button>
</section>

<script>
/* 
  Inline JS: Single-file offline SPA performing all required steps:
  - CSV parsing
  - Graph building (with fallback)
  - CPM computations (topological sort, forward/backward pass)
  - Per-edge free float
  - Backward path enumeration
  - Ranking, displaying top 3
  - Exporting results (2 CSV, 1 log)
  - Logging & acceptance checklist
  - Miminum error handling for invalid data
  - Offline, no external dependencies
  - Placeholders for advanced date/duration logic
  - Cancelling large tasks, responsive updates
*/
(function(){
  "use strict";

  // Application State
  const App = {
    state: "Idle", // "CSVLoaded","GraphBuilt","Analyzed","ExportReady"
    activities: {}, // key=ActivityID => { fields, adjacency, ES, EF, LS, LF, etc. }
    edges: [],      // list of {u,v, FF_edge}
    adjacency: {
      successors: {},
      predecessors: {}
    },
    logMessages: [],
    paths: [],
    top3: [],
    projectFinish: 0,
    cycleDetected: false,
    config: {
      fallbackMode: "strict",
      hoursPerDay: 8.0,
      unit: "days",
      maxPaths: 250,
      maxDepth: 500
    },
    sampleCSV: `Project ID,Activity ID,Activity Name,Activity Type,At Completion Duration,Start,Finish,Activity Status,Total Float,Primary Constraint,Predecessor Details,Predecessors,Successor Details,Successors
PROJ1,A100,Start Activity,Milestone,0,2023-10-01,2023-10-01,completed,0,,FS(0),,FS(0),A110
PROJ1,A110,Design,Task,3,2023-10-02,2023-10-04,in-progress,2,,,A100,FS(0),A120
PROJ1,A120,Review,Task,2,2023-10-05,2023-10-06,not started,2,,,A110,FS(0),A130
PROJ1,A130,Approval,Milestone,0,2023-10-07,2023-10-07,not started,1,,,A120,FS(0),A140
PROJ1,A140,Implementation,Task,5,2023-10-08,2023-10-12,not started,1,,,A130,FS(0),A150
PROJ1,A150,Closeout,Milestone,0,2023-10-13,2023-10-13,not started,0,,,A140,,
PROJ1,A999,Placeholder Test,Task,4,2023-10-02,2023-10-05,completed,3,,,X999,FS(0),A120
`,
    canceled: false
  };

  /* Utility Logging */
  function log(level, step, message) {
    const timestamp = new Date().toISOString();
    const msg = `[${timestamp}] [${level}] [${step}] ${message}`;
    App.logMessages.push(msg);
    const logPanel = document.getElementById("logPanel");
    if (logPanel) {
      logPanel.textContent += msg + "\n";
      logPanel.scrollTop = logPanel.scrollHeight;
    }
    console.log(msg);
  }

  function setState(newState) {
    App.state = newState;
    document.getElementById("appStateLabel").textContent = newState;
  }

  function updateChecklistItem(id, checked=true) {
    const el = document.getElementById(id);
    if (el) { el.checked = checked; }
  }

  /* CSV Parsing */
  function parseCSV(csvString) {
    log("INFO","LOAD_CSV","Parsing CSV...");
    const lines = csvString.split(/\r?\n/).filter(l=>!!l.trim());
    if (lines.length < 2) {
      log("ERROR","LOAD_CSV","Not enough rows, must have header + data");
      return [];
    }
    // Validate header
    const expectedHeaders = [
      "Project ID","Activity ID","Activity Name","Activity Type","At Completion Duration",
      "Start","Finish","Activity Status","Total Float","Primary Constraint",
      "Predecessor Details","Predecessors","Successor Details","Successors"
    ];
    const headerLine = lines[0];
    const headers = headerLine.split(",").map(h=>h.trim());
    if (JSON.stringify(headers) !== JSON.stringify(expectedHeaders)) {
      log("ERROR","VALIDATE_SCHEMA","Header mismatch");
      return [];
    }
    // parse data rows
    const dataRows = lines.slice(1);
    return dataRows.map(row => {
      const parts = row.split(",");
      // if row is incomplete, pad
      while (parts.length < headers.length) {
        parts.push("");
      }
      const obj = {};
      for (let i=0; i<headers.length; i++){
        obj[headers[i]] = parts[i] ? parts[i].trim() : "";
      }
      return obj;
    });
  }

  /* Build Graph */
  function buildGraph(records) {
    log("INFO","BUILD_GRAPH","Start building graph");
    // reset
    App.activities = {};
    App.adjacency.successors = {};
    App.adjacency.predecessors = {};
    App.edges = [];
    let rowCount = 0;

    for (let i=0;i<records.length;i++){
      const rec = records[i];
      const id = rec["Activity ID"];
      if (!id) {
        log("WARN","BUILD_GRAPH","Empty Activity ID found, skipping");
        continue;
      }
      // Check if we already have it
      if (App.activities[id]) {
        log("WARN","BUILD_GRAPH",`Duplicate Activity ID ${id}; ignoring subsequent`);
        continue;
      }
      // Basic normalizations
      let status = rec["Activity Status"] ? rec["Activity Status"].toLowerCase() : "not started";
      if (!["completed","in-progress","not started"].includes(status)) {
        log("WARN","BUILD_GRAPH",`Invalid status for ${id}; set to not started`);
        status = "not started";
      }
      let duration = parseFloat(rec["At Completion Duration"]);
      if (isNaN(duration)) {
        duration = 0;
        log("WARN","BUILD_GRAPH",`Duration invalid for ${id}, defaulting to 0`);
      }
      App.activities[id] = {
        projectID: rec["Project ID"],
        activityID: id,
        name: rec["Activity Name"],
        type: rec["Activity Type"],
        duration,
        start: rec["Start"],
        finish: rec["Finish"],
        status,
        totalFloat: parseFloat(rec["Total Float"]) || 0,
        earlyStart: null,
        earlyFinish: null,
        lateStart: null,
        lateFinish: null
      };
      App.adjacency.successors[id] = [];
      App.adjacency.predecessors[id] = [];
      rowCount++;
    }
    // build edges
    records.forEach(rec => {
      const fromID = rec["Activity ID"];
      const predList = rec["Predecessors"] ? rec["Predecessors"].split(/;/).map(e=>e.trim()).filter(x=>x) : [];
      const succList = rec["Successors"] ? rec["Successors"].split(/;/).map(e=>e.trim()).filter(x=>x) : [];
      // we have a directed edge from each pred->this
      predList.forEach(p => {
        if (App.activities[p]) {
          App.adjacency.successors[p].push(fromID);
          App.adjacency.predecessors[fromID].push(p);
        } else {
          if (App.config.fallbackMode === "placeholder"){
            const placeholderID = p;
            if (!App.activities[placeholderID]) {
              log("WARN","BUILD_GRAPH",`Creating placeholder for missing ${placeholderID}`);
              App.activities[placeholderID] = {
                projectID: "",
                activityID: placeholderID,
                name: "<MISSING:"+placeholderID+">",
                type: "placeholder",
                duration: 0,
                start: "",
                finish: "",
                status: "unknown",
                totalFloat: 0,
                earlyStart: null,
                earlyFinish: null,
                lateStart: null,
                lateFinish: null
              };
              App.adjacency.successors[placeholderID] = [];
              App.adjacency.predecessors[placeholderID] = [];
            }
            App.adjacency.successors[placeholderID].push(fromID);
            App.adjacency.predecessors[fromID].push(placeholderID);
          } else {
            log("ERROR","BUILD_GRAPH",`Missing predecessor reference ${p} for ${fromID}, ignoring`);
          }
        }
      });
      // we have a directed edge from this->succ
      succList.forEach(s => {
        if (App.activities[s]) {
          App.adjacency.successors[fromID].push(s);
          App.adjacency.predecessors[s].push(fromID);
        } else {
          if (App.config.fallbackMode === "placeholder"){
            const placeholderID = s;
            if (!App.activities[placeholderID]) {
              log("WARN","BUILD_GRAPH",`Creating placeholder for missing ${placeholderID}`);
              App.activities[placeholderID] = {
                projectID: "",
                activityID: placeholderID,
                name: "<MISSING:"+placeholderID+">",
                type: "placeholder",
                duration: 0,
                start: "",
                finish: "",
                status: "unknown",
                totalFloat: 0,
                earlyStart: null,
                earlyFinish: null,
                lateStart: null,
                lateFinish: null
              };
              App.adjacency.successors[placeholderID] = [];
              App.adjacency.predecessors[placeholderID] = [];
            }
            App.adjacency.successors[fromID].push(placeholderID);
            App.adjacency.predecessors[placeholderID].push(fromID);
          } else {
            log("ERROR","BUILD_GRAPH",`Missing successor reference ${s} for ${fromID}, ignoring`);
          }
        }
      });
    });
    document.getElementById("activityCount").textContent = Object.keys(App.activities).length;
    let eCount = 0;
    Object.keys(App.adjacency.successors).forEach(u => {
      eCount += App.adjacency.successors[u].length;
    });
    document.getElementById("edgeCount").textContent = eCount;
    log("INFO","BUILD_GRAPH",`Graph built with ${Object.keys(App.activities).length} activities, ${eCount} edges`);
    updateChecklistItem("chkGraphBuilt", true);
  }

  /* Detect cycles using Kahn's Algorithm, also build topological order if possible */
  function topologicalSort() {
    log("INFO","TOPO_SORT","Performing topological sort");
    const inDegree = {};
    const zeroInDegreeQueue = [];
    Object.keys(App.activities).forEach(id => {
      inDegree[id] = App.adjacency.predecessors[id].length;
    });
    Object.keys(inDegree).forEach(id => {
      if (inDegree[id] === 0) {
        zeroInDegreeQueue.push(id);
      }
    });
    const topoOrder = [];
    while (zeroInDegreeQueue.length > 0) {
      const u = zeroInDegreeQueue.shift();
      topoOrder.push(u);
      const succs = App.adjacency.successors[u] || [];
      succs.forEach(v => {
        inDegree[v]--;
        if (inDegree[v]===0) {
          zeroInDegreeQueue.push(v);
        }
      });
    }
    if (topoOrder.length < Object.keys(App.activities).length) {
      // cycle
      log("ERROR","TOPO_SORT","Cycle detected, analysis blocked.");
      App.cycleDetected = true;
      document.getElementById("cycleDetected").textContent = "Yes";
    } else {
      App.cycleDetected = false;
      document.getElementById("cycleDetected").textContent = "No";
    }
    return topoOrder;
  }

  /* Forward Pass to compute ES, EF */
  function forwardPass(topoOrder) {
    log("INFO","FORWARD_PASS","Computing ES/EF");
    App.projectFinish = 0;
    topoOrder.forEach(id => {
      const act = App.activities[id];
      const preds = App.adjacency.predecessors[id];
      let es = 0;
      preds.forEach(p => {
        const pAct = App.activities[p];
        if (pAct && pAct.earlyFinish!=null) {
          if (pAct.earlyFinish>es) es = pAct.earlyFinish;
        }
      });
      act.earlyStart = es;
      act.earlyFinish = es + act.duration;
      if (act.earlyFinish>App.projectFinish) {
        App.projectFinish = act.earlyFinish;
      }
    });
  }

  /* Backward Pass to compute LS, LF */
  function backwardPass(topoOrder) {
    log("INFO","BACKWARD_PASS","Computing LS/LF");
    const revOrder = [...topoOrder].reverse();
    revOrder.forEach(id => {
      const act = App.activities[id];
      if (App.adjacency.successors[id].length === 0) {
        act.lateFinish = App.projectFinish;
      } else {
        let minLS = Infinity;
        App.adjacency.successors[id].forEach(s => {
          const sAct = App.activities[s];
          if (sAct && sAct.lateStart!=null && sAct.lateStart<minLS) {
            minLS = sAct.lateStart;
          }
        });
        if (minLS===Infinity) {
          act.lateFinish = App.projectFinish;
        } else {
          act.lateFinish = minLS;
        }
      }
      act.lateStart = act.lateFinish - act.duration;
    });
  }

  /* Compute per-edge free float: FF_edge(u->v) = ES(v) - EF(u) */
  function computeEdgeFF() {
    log("INFO","FF_EDGES","Computing free float per edge");
    const allEdges = [];
    Object.keys(App.adjacency.successors).forEach(u => {
      const uAct = App.activities[u];
      App.adjacency.successors[u].forEach(v => {
        const vAct = App.activities[v];
        let ff = 0;
        if (uAct.earlyFinish!=null && vAct.earlyStart!=null) {
          ff = vAct.earlyStart - uAct.earlyFinish;
        } else {
          log("ERROR","FF_EDGES",`Missing ES/EF for edge ${u}->${v}, skipping`);
          return;
        }
        allEdges.push({u,v,FF_edge: ff});
      });
    });
    App.edges = allEdges;
  }

  /* Enumerate all backward paths from a start node until encountering a completed node. */
  function enumerateBackwardPaths(startID) {
    log("INFO","ENUMERATE_PATHS",`Start enumerating backward paths from ${startID}`);
    App.paths = [];
    let stack = [];
    let resultsCount = 0;
    let maxPaths = App.config.maxPaths;
    let maxDepth = App.config.maxDepth;

    const startStatus = App.activities[startID] ? App.activities[startID].status : "unknown";
    if (startStatus==="completed") {
      App.paths.push({
        nodeSequence: [startID],
        edgeList: [],
        totalFF: 0,
        edgesCount: 0,
        terminalID: startID
      });
      return;
    }

    stack.push({path:[startID], depth:0, totalFF:0});
    while (stack.length>0) {
      if (App.canceled) {
        log("WARN","ENUMERATE_PATHS","Operation aborted by user");
        return;
      }
      const {path, depth, totalFF} = stack.pop();
      const current = path[path.length-1];
      const preds = App.adjacency.predecessors[current] || [];
      if (preds.length===0) {
      } else {
        for (let i=0; i<preds.length; i++){
          const p = preds[i];
          if (App.activities[p].status==="completed") {
            const edgeFF = getEdgeFF(p,current);
            const finalFF = totalFF + edgeFF;
            const newPath = [...path,p];
            App.paths.push({
              nodeSequence: newPath,
              edgeList: [],
              totalFF: finalFF,
              edgesCount: newPath.length-1,
              terminalID: p
            });
            resultsCount++;
            if (resultsCount>=maxPaths) {
              log("WARN","ENUMERATE_PATHS","Reached MaxPaths limit");
              return;
            }
          } else if (App.activities[p].type==="placeholder") {
          } else {
            if (path.includes(p)) {
            } else {
              if (depth+1>maxDepth) {
                log("WARN","ENUMERATE_PATHS","MaxDepth limit reached");
              } else {
                const edgeFF = getEdgeFF(p,current);
                stack.push({
                  path:[...path,p],
                  depth: depth+1,
                  totalFF: totalFF + edgeFF
                });
              }
            }
          }
        }
      }
    }
  }
  function getEdgeFF(u,v) {
    const e = App.edges.find(ed => ed.u===u && ed.v===v);
    return e ? e.FF_edge : 0;
  }

  /* Rank the found paths */
  function rankPaths() {
    log("INFO","RANK_PATHS","Ranking paths");
    App.paths.forEach(p => {
      p.edgeList = [];
      p.bottleneckEdgeFF = Infinity;
      for (let i=0; i<p.nodeSequence.length-1; i++){
        const v = p.nodeSequence[i];
        const u = p.nodeSequence[i+1];
        const eFF = getEdgeFF(u,v);
        if (eFF < p.bottleneckEdgeFF) {
          p.bottleneckEdgeFF = eFF;
        }
        p.edgeList.push({u, v, ff:eFF});
      }
      p.idSequence = p.nodeSequence.slice().reverse().join(">");
    });
    App.paths.sort((a,b)=>{
      if (a.totalFF!==b.totalFF) return a.totalFF - b.totalFF;
      if (a.edgesCount!==b.edgesCount) return a.edgesCount - b.edgesCount;
      if (a.idSequence<b.idSequence) return -1;
      if (a.idSequence>b.idSequence) return 1;
      return 0;
    });
    App.top3 = App.paths.slice(0,3);
  }

  /* Populate UI with top3 & detailed */
  function renderPathTables() {
    log("INFO","RENDER","Rendering path tables");
    const t3body = document.querySelector("#top3Table tbody");
    t3body.innerHTML = "";
    App.top3.forEach((p,idx)=>{
      const tr = document.createElement("tr");
      const rankTd = document.createElement("td");
      rankTd.textContent = idx+1;
      const totalFFTd = document.createElement("td");
      totalFFTd.textContent = formatFloat(p.totalFF);
      const edgesTd = document.createElement("td");
      edgesTd.textContent = p.edgesCount;
      const bottleneckTd = document.createElement("td");
      bottleneckTd.textContent = formatFloat(p.bottleneckEdgeFF);
      const terminalTd = document.createElement("td");
      terminalTd.textContent = p.terminalID;
      const pathTd = document.createElement("td");
      pathTd.textContent = p.nodeSequence.slice().reverse().join(">");
      tr.appendChild(rankTd);
      tr.appendChild(totalFFTd);
      tr.appendChild(edgesTd);
      tr.appendChild(bottleneckTd);
      tr.appendChild(terminalTd);
      tr.appendChild(pathTd);
      t3body.appendChild(tr);
    });

    const detailBody = document.querySelector("#detailedPathsTable tbody");
    detailBody.innerHTML = "";
    App.paths.forEach((p,idx)=>{
      const tr = document.createElement("tr");
      const rankTd = document.createElement("td");
      rankTd.textContent = idx+1;
      const totalFFTd = document.createElement("td");
      totalFFTd.textContent = formatFloat(p.totalFF);
      const edgesTd = document.createElement("td");
      edgesTd.textContent = p.edgesCount;
      const bottleneckTd = document.createElement("td");
      bottleneckTd.textContent = formatFloat(p.bottleneckEdgeFF);
      const terminalTd = document.createElement("td");
      terminalTd.textContent = p.terminalID;
      const pathTd = document.createElement("td");
      pathTd.textContent = p.idSequence;
      const perEdgeTd = document.createElement("td");
      const ffStrings = p.edgeList.map(e => formatFloat(e.ff));
      perEdgeTd.textContent = ffStrings.join(";");
      const notesTd = document.createElement("td");
      notesTd.textContent = "";
      tr.appendChild(rankTd);
      tr.appendChild(totalFFTd);
      tr.appendChild(edgesTd);
      tr.appendChild(bottleneckTd);
      tr.appendChild(terminalTd);
      tr.appendChild(pathTd);
      tr.appendChild(perEdgeTd);
      tr.appendChild(notesTd);
      detailBody.appendChild(tr);
    });
  }

  /* Format float in current unit */
  function formatFloat(value) {
    if (App.config.unit==="hours") {
      return (value*App.config.hoursPerDay).toFixed(2);
    } else {
      return value.toFixed(2);
    }
  }

  /* Exports: Paths.csv, Summary.csv, AnalysisLog.txt */
  function exportResults() {
    if (!App.paths.length) {
      log("WARN","EXPORT","No paths to export");
      return;
    }
    let pathsCsv = "Rank,TotalFF_Days,TotalFF_Hours,EdgesCount,BottleneckFF_Days,BottleneckEdge,TerminalCompletedID,PathIDs,PerEdgeFF_Days,Aborted,Notes\n";
    App.paths.forEach((p,idx)=>{
      const rank = idx+1;
      const tffDays = p.totalFF.toFixed(2);
      const tffHours = (p.totalFF*App.config.hoursPerDay).toFixed(2);
      const bottleneckDays = p.bottleneckEdgeFF.toFixed(2);
      let bEdge = "";
      if (p.edgeList.length>0) {
        const bn = p.edgeList.find(x=>x.ff===p.bottleneckEdgeFF);
        if (bn) { bEdge = bn.u+"->"+bn.v; }
      }
      const terminal = p.terminalID;
      const pathIds = p.nodeSequence.slice().reverse().join(">");
      const perEdgeDays = p.edgeList.map(e=> e.ff.toFixed(2)).join(";");
      const aborted = "false";
      const notes = "";
      const row = [
        rank, tffDays, tffHours, p.edgesCount, bottleneckDays, bEdge, terminal, pathIds, perEdgeDays, aborted, notes
      ].map(x=>`"${x}"`).join(",");
      pathsCsv += row + "\n";
    });
    let summaryCsv = "Rank,TotalFF_Days,TotalFF_Hours,EdgesCount,BottleneckFF_Days,BottleneckEdge,TerminalCompletedID,PathIDs,PerEdgeFF_Days,Aborted,Notes\n";
    App.top3.forEach((p,idx)=>{
      const rank = idx+1;
      const tffDays = p.totalFF.toFixed(2);
      const tffHours = (p.totalFF*App.config.hoursPerDay).toFixed(2);
      const bottleneckDays = p.bottleneckEdgeFF.toFixed(2);
      let bEdge = "";
      if (p.edgeList.length>0) {
        const bn = p.edgeList.find(x=>x.ff===p.bottleneckEdgeFF);
        if (bn) { bEdge = bn.u+"->"+bn.v; }
      }
      const terminal = p.terminalID;
      const pathIds = p.nodeSequence.slice().reverse().join(">");
      const perEdgeDays = p.edgeList.map(e=> e.ff.toFixed(2)).join(";");
      const aborted = "false";
      const notes = "";
      const row = [
        rank, tffDays, tffHours, p.edgesCount, bottleneckDays, bEdge, terminal, pathIds, perEdgeDays, aborted, notes
      ].map(x=>`"${x}"`).join(",");
      summaryCsv += row + "\n";
    });
    const logText = App.logMessages.join("\n");
    downloadFile(pathsCsv,"Paths.csv","text/csv");
    downloadFile(summaryCsv,"Summary.csv","text/csv");
    downloadFile(logText,"AnalysisLog.txt","text/plain");
    log("INFO","EXPORT","Files exported");
    updateChecklistItem("chkExportReady", true);
  }

  function downloadFile(content, filename, type) {
    const blob = new Blob([content], {type});
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
  }

  /* Orchestrate Analysis */
  function doAnalysis() {
    const t0 = performance.now();
    setState("Analyzed");
    document.getElementById("globalProgress").value = 0;
    document.getElementById("progressLabel").textContent = "Analysis in progress...";
    updateChecklistItem("chkPathsFound", false);
    updateChecklistItem("chkPathsRanked", false);
    const topoOrder = topologicalSort();
    if (App.cycleDetected) return;
    document.getElementById("globalProgress").value = 10;
    forwardPass(topoOrder);
    document.getElementById("globalProgress").value = 25;
    backwardPass(topoOrder);
    document.getElementById("globalProgress").value = 40;
    updateChecklistItem("chkCpmTimes", true);
    computeEdgeFF();
    updateChecklistItem("chkFreeFloat", true);
    document.getElementById("globalProgress").value = 50;
    document.getElementById("projectFinish").textContent = App.projectFinish.toFixed(2);
    App.canceled = false;
    enumerateBackwardPaths(document.getElementById("startActivityId").value.trim());
    updateChecklistItem("chkPathsFound", App.paths.length>0);
    document.getElementById("globalProgress").value = 70;
    rankPaths();
    updateChecklistItem("chkPathsRanked", true);
    document.getElementById("globalProgress").value = 80;
    renderPathTables();
    document.getElementById("globalProgress").value = 100;
    document.getElementById("progressLabel").textContent = "Done.";
    setState("ExportReady");
    const t1 = performance.now();
    document.getElementById("analysisTime").textContent = (t1 - t0).toFixed(2);
  }

  /* New unified file handler */
  function handleFile(file) {
    if (!file) return;
    if (file.size > 10*1024*1024) {
      log("WARN","LOAD_CSV","File too large (>10MB), proceed with caution");
    }
    const reader = new FileReader();
    reader.onload = (e) => {
      const text = e.target.result;
      const records = parseCSV(text);
      if (!records.length) {
        return;
      }
      updateChecklistItem("chkCsvParsed", true);
      setState("CSVLoaded");
      document.getElementById("csvRowCount").textContent = "Rows: "+records.length;
      buildGraph(records);
    };
    reader.readAsText(file);
  }

  function onFileSelected(evt) {
    const file = evt.target.files[0];
    handleFile(file);
  }

  function onDragOver(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    evt.dataTransfer.dropEffect = "copy";
    document.getElementById("dragDropArea").classList.add("dragover");
  }

  function onDragLeave(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    document.getElementById("dragDropArea").classList.remove("dragover");
  }

  function onDrop(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    document.getElementById("dragDropArea").classList.remove("dragover");
    const file = evt.dataTransfer.files[0];
    handleFile(file);
  }

  /* Self Test: load sample, build graph, analyze, check results */
  function runSelfTest() {
    log("INFO","SELF_TEST","Running self-test with embedded sample CSV");
    resetApp(false);
    document.getElementById("csvRowCount").textContent = "Sample loaded, " + App.sampleCSV.split("\n").length + " lines";
    const records = parseCSV(App.sampleCSV);
    if (!records.length) {
      log("ERROR","SELF_TEST","Parsing sample CSV failed");
      return;
    }
    updateChecklistItem("chkCsvParsed", true);
    setState("CSVLoaded");
    buildGraph(records);
    document.getElementById("startActivityId").value = "A120";
    doAnalysis();
  }

  /* Reset application state */
  function resetApp(confirmNeeded=true) {
    if (confirmNeeded) {
      if(!window.confirm("Reset application state?")) return;
    }
    App.state = "Idle";
    App.activities = {};
    App.edges = [];
    App.adjacency.successors = {};
    App.adjacency.predecessors = {};
    App.paths = [];
    App.top3 = [];
    App.cycleDetected = false;
    App.logMessages = [];
    App.projectFinish = 0;
    App.canceled = false;
    document.getElementById("logPanel").textContent = "";
    document.getElementById("activityCount").textContent = "0";
    document.getElementById("edgeCount").textContent = "0";
    document.getElementById("cycleDetected").textContent = "No";
    document.getElementById("projectFinish").textContent = "---";
    document.getElementById("analysisTime").textContent = "0";
    document.querySelector("#top3Table tbody").innerHTML = "";
    document.querySelector("#detailedPathsTable tbody").innerHTML = "";
    document.getElementById("csvRowCount").textContent = "";
    setState("Idle");
    document.getElementById("globalProgress").value = 0;
    document.getElementById("progressLabel").textContent = "";
    ["chkCsvParsed","chkGraphBuilt","chkNoCycles","chkCpmTimes","chkFreeFloat","chkPathsFound","chkPathsRanked","chkExportReady","chkLogAvailable","chkUnitToggle"]
    .forEach(id => updateChecklistItem(id,false));
  }

  /* UI Setup */
  window.addEventListener("DOMContentLoaded", () => {
    document.getElementById("loadSampleBtn").addEventListener("click", ()=>{
      resetApp(false);
      const records = parseCSV(App.sampleCSV);
      if (!records.length) return;
      updateChecklistItem("chkCsvParsed", true);
      setState("CSVLoaded");
      document.getElementById("csvRowCount").textContent = "Sample loaded, " + records.length + " rows";
      buildGraph(records);
    });
    document.getElementById("csvFile").addEventListener("change", onFileSelected);
    const dropArea = document.getElementById("dragDropArea");
    dropArea.addEventListener("click", ()=> document.getElementById("csvFile").click());
    dropArea.addEventListener("dragover", onDragOver);
    dropArea.addEventListener("dragleave", onDragLeave);
    dropArea.addEventListener("drop", onDrop);

    document.getElementById("buildGraphBtn").addEventListener("click", ()=>{
      if (App.state==="CSVLoaded") {
        log("INFO","BUILD_GRAPH","Graph build requested again. Reload or new parse if needed.");
      }
    });
    document.getElementById("analyzePathsBtn").addEventListener("click", ()=>{
      if (!App.cycleDetected && App.state!=="Idle" && document.getElementById("startActivityId").value.trim()!=="") {
        doAnalysis();
      }
    });
    document.getElementById("exportBtn").addEventListener("click", ()=>{
      exportResults();
    });
    document.getElementById("resetBtn").addEventListener("click", ()=>{
      resetApp(true);
    });
    document.getElementById("cancelBtn").addEventListener("click", ()=>{
      App.canceled = true;
    });
    document.getElementById("themeToggleBtn").addEventListener("click", toggleTheme);
    document.getElementById("settingsBtn").addEventListener("click", ()=>{
      document.getElementById("settingsPanel").classList.add("open");
    });
    document.getElementById("closeSettingsBtn").addEventListener("click", ()=>{
      document.getElementById("settingsPanel").classList.remove("open");
    });
    document.getElementById("helpBtn").addEventListener("click", ()=>{
      document.getElementById("helpModal").classList.add("open");
    });
    document.getElementById("closeHelpBtn").addEventListener("click", ()=>{
      document.getElementById("helpModal").classList.remove("open");
    });
    document.getElementById("logToggleBtn").addEventListener("click", ()=>{
      const lp = document.getElementById("logPanel");
      lp.classList.toggle("open");
      updateChecklistItem("chkLogAvailable", lp.classList.contains("open"));
    });
    document.getElementById("selfTestBtn").addEventListener("click", runSelfTest);

    document.getElementById("unitToggle").addEventListener("change", (evt)=>{
      App.config.unit = evt.target.value;
      updateChecklistItem("chkUnitToggle", true);
      renderPathTables();
    });
    document.getElementById("hoursPerDay").addEventListener("change",(evt)=>{
      let val = parseFloat(evt.target.value);
      if (isNaN(val) || val<1 || val>24) {
        val = 8;
      }
      App.config.hoursPerDay = val;
      renderPathTables();
    });
    document.getElementById("fallbackMode").addEventListener("change",(evt)=>{
      App.config.fallbackMode = evt.target.value;
    });
    document.getElementById("maxPaths").addEventListener("change",(evt)=>{
      let val = parseInt(evt.target.value);
      if (isNaN(val) || val<1) { val=1; }
      if (val>100000) {
        log("WARN","SETTINGS","maxPaths very large, performance risk");
      }
      App.config.maxPaths = val;
    });
    document.getElementById("maxDepth").addEventListener("change",(evt)=>{
      let val = parseInt(evt.target.value);
      if (isNaN(val) || val<10) { val=10; }
      if (val>10000) {
        log("WARN","SETTINGS","maxDepth very large, performance risk");
      }
      App.config.maxDepth = val;
    });
    window.addEventListener("keydown",(evt)=>{
      if (evt.key==="?"){
        document.getElementById("helpModal").classList.toggle("open");
      } else if (evt.key==="t"){
        toggleTheme();
      } else if (evt.key==="g"){
        if (App.state==="CSVLoaded") {
          log("INFO","BUILD_GRAPH","Graph build requested via keyboard. Reload or new parse if needed.");
        }
      } else if (evt.key==="a"){
        if (!App.cycleDetected && App.state!=="Idle" && document.getElementById("startActivityId").value.trim()!=="") {
          doAnalysis();
        }
      } else if (evt.key==="e"){
        exportResults();
      } else if (evt.key==="l"){
        document.getElementById("logPanel").classList.toggle("open");
      }
    });
    function toggleTheme(){
      if (document.body.classList.contains("light")) {
        document.body.classList.remove("light");
        document.body.classList.add("dark");
      } else {
        document.body.classList.remove("dark");
        document.body.classList.add("light");
      }
    }
  });
})();
</script>
</body>
</html>
