<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>CPM Backward Path Analyzer</title>
<style>
/* 
  Inline CSS for a two-column responsive layout, 
  minimal styling for clarity and offline usage, 
  ensuring no external resources.
*/
:root {
  --bg-light: #ffffff;
  --fg-light: #000000;
  --bg-dark: #2a2a2a;
  --fg-dark: #f0f0f0;
  --accent-color: #007acc;
  --danger-color: #b00020;
  --success-color: #018786;
  --warn-color: #ae7f00;
  --info-color: #25627e;
  --font-family: sans-serif;
  --header-height: 60px;
  --transition-speed: 0.3s;
  --border-radius: 4px;
  --border-color: #ccc;
  --column-gap: 16px;
}

[data-theme='light'] {
  --bg-color: var(--bg-light);
  --fg-color: var(--fg-light);
}
[data-theme='dark'] {
  --bg-color: var(--bg-dark);
  --fg-color: var(--fg-dark);
}

html, body {
  margin: 0;
  padding: 0;
  font-family: var(--font-family);
  background-color: var(--bg-color);
  color: var(--fg-color);
  transition: background-color var(--transition-speed), color var(--transition-speed);
  height: 100%;
}

body[data-theme='dark'] {
  background-color: var(--bg-dark);
  color: var(--fg-dark);
}

header, footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: var(--header-height);
  padding: 0 16px;
  background-color: var(--accent-color);
  color: #fff;
}

header button, footer button, header select, footer select {
  background-color: transparent;
  border: none;
  color: #fff;
  cursor: pointer;
  margin-left: 8px;
}
header button:hover {
  opacity: 0.8;
}

h1 {
  font-size: 1.25rem;
  margin: 0;
}

main {
  display: grid;
  grid-template-columns: 1fr 2fr;
  grid-gap: var(--column-gap);
  padding: 8px 16px;
}
@media (max-width: 768px) {
  main {
    grid-template-columns: 1fr;
  }
}

section {
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 8px;
  margin-bottom: 8px;
  overflow: auto;
}

label {
  display: inline-block;
  margin-top: 8px;
}

input, select, textarea {
  width: 100%;
  margin-top: 4px;
  margin-bottom: 12px;
  box-sizing: border-box;
}

button {
  padding: 6px 12px;
  border-radius: var(--border-radius);
  cursor: pointer;
  border: 1px solid var(--border-color);
  background-color: var(--accent-color);
  color: #fff;
  text-transform: uppercase;
  font-weight: bold;
}
button:hover {
  filter: brightness(0.9);
}

#topCards {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.card {
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 8px;
  min-width: 120px;
  text-align: center;
  flex: 1;
}

#pathsTableContainer {
  height: 150px; /* Virtualized small container for demonstration */
  overflow: auto;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
}

table {
  width: 100%;
  border-collapse: collapse;
}
th, td {
  border-bottom: 1px solid var(--border-color);
  padding: 4px 8px;
  text-align: left;
}

#logPanel {
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 8px;
  max-height: 200px;
  overflow: auto;
  background-color: #fafafa;
  color: #000;
  display: none;
}
#logPanel.visible {
  display: block;
}
.log-entry {
  font-size: 0.85rem;
  margin: 2px 0;
}
.log-entry.error {
  color: var(--danger-color);
}
.log-entry.warn {
  color: var(--warn-color);
}
.log-entry.info {
  color: var(--info-color);
}
.log-entry.success {
  color: var(--success-color);
}

footer {
  background-color: var(--accent-color);
  color: #fff;
  padding: 0 16px;
  font-size: 0.85rem;
  justify-content: space-evenly;
  flex-wrap: wrap;
}
footer .checklist {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}
footer .checklist label {
  display: flex;
  align-items: center;
}

.check-item {
  margin: 4px 0;
}

.hidden {
  display: none !important;
}

.modalOverlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
.modalOverlay.show {
  display: flex;
}
.modalContent {
  background: #fff;
  color: #000;
  padding: 20px;
  border-radius: var(--border-radius);
  max-width: 600px;
  max-height: 80%;
  overflow: auto;
}
button.closeModal {
  background-color: var(--danger-color);
  color: #fff;
}
</style>
</head>
<body data-theme="light">
<!-- 
  Single-page application (SPA) implementing 
  offline CPM backward path analysis. 
  All functionality is contained within this one file.
-->
<header>
  <h1>CPM Backward Path Analyzer</h1>
  <div style="display:flex;align-items:center;">
    <button id="btnThemeToggle" aria-label="Toggle Theme (t)">Light/Dark</button>
    <button id="btnHelp" aria-label="Help (?)">Help</button>
    <button id="btnSettings" aria-label="Settings">Settings</button>
  </div>
</header>
<main>
  <!-- LEFT PANEL: Controls -->
  <div>
    <section>
      <h3>CSV Input</h3>
      <p><input type="file" id="fileInput" accept=".csv" /></p>
      <button id="btnLoadSample" aria-label="Load Sample CSV">Load Sample</button>
      <div id="csvInfo"></div>
    </section>

    <section id="settingsPanel" class="hidden">
      <h3>Settings</h3>
      <label for="unitsToggle">Units</label>
      <select id="unitsToggle">
        <option value="days" selected>Days</option>
        <option value="hours">Hours</option>
      </select>
      <label for="hoursPerDay">Hours/Day</label>
      <input type="number" id="hoursPerDay" value="8.00" min="1" max="24" step="0.25"/>
      <label for="fallbackMode">Graph Fallbacks Mode</label>
      <select id="fallbackMode">
        <option value="strict" selected>Strict</option>
        <option value="placeholder">Placeholder</option>
      </select>
      <label for="maxPaths">Max Paths</label>
      <input type="number" id="maxPaths" value="250" min="1" max="100000" />
      <label for="maxDepth">Max Depth</label>
      <input type="number" id="maxDepth" value="500" min="10" max="10000" />
    </section>

    <section>
      <h3>Analyze</h3>
      <label for="startActivitySelect">Start Activity ID</label>
      <select id="startActivitySelect"></select>
      <button id="btnBuildGraph" aria-label="Build Graph (g)" disabled>Build Graph</button>
      <button id="btnAnalyze" aria-label="Analyze Paths (a)" disabled>Analyze Paths</button>
      <button id="btnCancelStop" class="hidden" aria-label="Cancel/Stop">Cancel</button>
      <button id="btnReset" aria-label="Reset">Reset</button>
    </section>

    <section>
      <h3>Export</h3>
      <button id="btnExport" aria-label="Export (e)" disabled>Export</button>
      <button id="btnToggleLog" aria-label="Toggle Log (l)">Log Panel</button>
      <div id="statusBadges">
        <div>Status: <span id="appState">Idle</span></div>
      </div>
    </section>
  </div>

  <!-- RIGHT PANEL: Results -->
  <div>
    <section>
      <div id="topCards">
        <div class="card">
          <strong>Activities</strong>
          <div id="cardActivitiesCount">0</div>
        </div>
        <div class="card">
          <strong>Edges</strong>
          <div id="cardEdgesCount">0</div>
        </div>
        <div class="card">
          <strong>Cycle Detected</strong>
          <div id="cardCycleDetected">No</div>
        </div>
        <div class="card">
          <strong>Project Finish</strong>
          <div id="cardProjectFinish">N/A</div>
        </div>
        <div class="card">
          <strong>Analysis Time (ms)</strong>
          <div id="cardAnalysisTime">0</div>
        </div>
      </div>
    </section>

    <section>
      <h3>Top 3 Paths Preview</h3>
      <table>
        <thead>
          <tr>
            <th>Rank</th>
            <th>Total FF</th>
            <th># Edges</th>
            <th>Bottleneck FF</th>
            <th>Terminal Completed ID</th>
            <th>Path</th>
          </tr>
        </thead>
        <tbody id="top3TableBody">
        </tbody>
      </table>
    </section>

    <section>
      <h3>Detailed Paths</h3>
      <div id="pathsTableContainer">
        <table>
          <thead>
            <tr>
              <th>Rank</th>
              <th>TotalFF</th>
              <th>Edges</th>
              <th>BottleneckFF</th>
              <th>TerminalID</th>
              <th>Path IDs</th>
              <th>Per-Edge FF</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody id="pathsTableBody">
            <!-- Rows dynamically generated -->
          </tbody>
        </table>
      </div>
    </section>
    <section>
      <h3>Log Panel</h3>
      <div id="logPanel"></div>
      <button id="btnDownloadLog">Download Log</button>
    </section>
  </div>
</main>

<footer>
  <div class="checklist">
    <h4>Acceptance Checklist</h4>
    <label class="check-item"><input type="checkbox" id="chkCsvParsed" disabled> CSV parsed (schema validated)</label>
    <label class="check-item"><input type="checkbox" id="chkGraphBuilt" disabled> Graph built (bidirectional)</label>
    <label class="check-item"><input type="checkbox" id="chkNoCycles" disabled> No cycles detected</label>
    <label class="check-item"><input type="checkbox" id="chkCpmTimes" disabled> CPM times computed</label>
    <label class="check-item"><input type="checkbox" id="chkFfComputed" disabled> Edge free float computed</label>
    <label class="check-item"><input type="checkbox" id="chkPathsFound" disabled> Backward paths enumerated</label>
    <label class="check-item"><input type="checkbox" id="chkPathsRanked" disabled> Paths ranked, top 3 displayed</label>
    <label class="check-item"><input type="checkbox" id="chkOutputsReady" disabled> Output files generated</label>
    <label class="check-item"><input type="checkbox" id="chkLogAvailable" disabled> Log available</label>
  </div>
  <div class="buildInfo">
    <div>Build: v1.0 | <span id="buildDate"></span></div>
    <button id="btnSelfTest">Run Self-Test</button>
  </div>
</footer>

<!-- Hidden modals for help and more -->
<div id="helpModal" class="modalOverlay" aria-hidden="true">
  <div class="modalContent">
    <h2>Help</h2>
    <p>Keyboard shortcuts: ? = Help, t = Toggle Theme, g = Build Graph, a = Analyze, e = Export, l = Toggle Log.</p>
    <button class="closeModal" data-close-modal="helpModal">Close</button>
  </div>
</div>
<div id="settingsModal" class="modalOverlay" aria-hidden="true">
  <div class="modalContent">
    <h2>Settings</h2>
    <p>Use the left panel settings section to configure the analysis. This modal is for demonstration only.</p>
    <button class="closeModal" data-close-modal="settingsModal">Close</button>
  </div>
</div>

<script>
/* 
  Single-file JavaScript to handle:
  1. CSV parsing and validation
  2. Graph building, cycle detection, topological sort
  3. CPM forward/backward passes, free float computations
  4. Backward path enumeration
  5. Ranking and output generation
  6. UI updates, logging, responsive interactions
  7. Offline usage with no external assets
*/
(function(){
  'use strict';

  // State machine
  const STATES = {
    IDLE: 'Idle',
    CSV_LOADED: 'CSVLoaded',
    GRAPH_BUILT: 'GraphBuilt',
    ANALYZED: 'Analyzed',
    EXPORT_READY: 'ExportReady'
  };
  let appState = STATES.IDLE;

  // DOM references
  const fileInput = document.getElementById('fileInput');
  const csvInfo = document.getElementById('csvInfo');
  const btnLoadSample = document.getElementById('btnLoadSample');
  const btnBuildGraph = document.getElementById('btnBuildGraph');
  const btnAnalyze = document.getElementById('btnAnalyze');
  const btnExport = document.getElementById('btnExport');
  const btnReset = document.getElementById('btnReset');
  const btnCancelStop = document.getElementById('btnCancelStop');
  const btnThemeToggle = document.getElementById('btnThemeToggle');
  const btnHelp = document.getElementById('btnHelp');
  const btnSettings = document.getElementById('btnSettings');
  const btnToggleLog = document.getElementById('btnToggleLog');
  const btnDownloadLog = document.getElementById('btnDownloadLog');
  const startActivitySelect = document.getElementById('startActivitySelect');
  const logPanel = document.getElementById('logPanel');
  const appStateSpan = document.getElementById('appState');
  const cardActivitiesCount = document.getElementById('cardActivitiesCount');
  const cardEdgesCount = document.getElementById('cardEdgesCount');
  const cardCycleDetected = document.getElementById('cardCycleDetected');
  const cardProjectFinish = document.getElementById('cardProjectFinish');
  const cardAnalysisTime = document.getElementById('cardAnalysisTime');
  const top3TableBody = document.getElementById('top3TableBody');
  const pathsTableBody = document.getElementById('pathsTableBody');
  const btnSelfTest = document.getElementById('btnSelfTest');
  const unitsToggle = document.getElementById('unitsToggle');
  const hoursPerDayInput = document.getElementById('hoursPerDay');
  const fallbackModeSelect = document.getElementById('fallbackMode');
  const maxPathsInput = document.getElementById('maxPaths');
  const maxDepthInput = document.getElementById('maxDepth');
  const chkCsvParsed = document.getElementById('chkCsvParsed');
  const chkGraphBuilt = document.getElementById('chkGraphBuilt');
  const chkNoCycles = document.getElementById('chkNoCycles');
  const chkCpmTimes = document.getElementById('chkCpmTimes');
  const chkFfComputed = document.getElementById('chkFfComputed');
  const chkPathsFound = document.getElementById('chkPathsFound');
  const chkPathsRanked = document.getElementById('chkPathsRanked');
  const chkOutputsReady = document.getElementById('chkOutputsReady');
  const chkLogAvailable = document.getElementById('chkLogAvailable');
  const buildDateSpan = document.getElementById('buildDate');
  const helpModal = document.getElementById('helpModal');
  const settingsModal = document.getElementById('settingsModal');
  const settingsPanel = document.getElementById('settingsPanel');

  // Logging
  let logEntries = [];
  function log(level, step, message){
    const timestamp = new Date().toISOString();
    logEntries.push({timestamp, level, step, message});
    const entryDiv = document.createElement('div');
    entryDiv.classList.add('log-entry', level.toLowerCase());
    entryDiv.textContent = `${timestamp} [${level}] [${step}] ${message}`;
    logPanel.appendChild(entryDiv);
    logPanel.scrollTop = logPanel.scrollHeight;
  }

  // Sample CSV embedded
  const sampleCSV = `Project ID,Activity ID,Activity Name,Activity Type,At Completion Duration,Start,Finish,Activity Status,Total Float,Primary Constraint,Predecessor Details,Predecessors,Successor Details,Successors
P123,A1,Start Milestone,Milestone,0,2023-10-01,2023-10-01,completed,0,,FS,,"A2"
P123,A2,Activity Two,Task,3,2023-10-02,2023-10-04,in progress,2,,,A1,"A3"
P123,A3,Activity Three,Task,4,2023-10-05,2023-10-08,not started,1,,,A2,"A4"
P123,A4,Finish Milestone,Milestone,0,2023-10-09,2023-10-09,not started,0,,,A3,
P123,A5,Placeholder Demo,Task,5,2023-10-10,2023-10-15,completed,,,"MISSING1"||
`;

  // Data structures
  let csvDataRows = [];
  let activityMap = new Map(); // key: ActivityID, value: { ...data... }
  let edges = []; // array of {u,v,FF_edge}
  let adjacencySuccessors = new Map();
  let adjacencyPredecessors = new Map();
  let cycleDetected = false;
  let analysisAborted = false;
  let enumeratedPaths = [];
  let cpmProjectFinish = 0;

  // Utility
  function parseCSV(text){
    // Minimal CSV parser for demonstration
    log('INFO','LOAD_CSV','Parsing CSV text...');
    const lines = text.split(/\r?\n/);
    let header = null;
    let rows = [];
    for(let i=0; i<lines.length; i++){
      let line = lines[i].trim();
      if(!line) continue;
      if(!header){
        header = line.split(',');
        header = header.map(h => h.trim());
      } else {
        // parse row
        let cols = line.split(',');
        cols = cols.map(c => c.trim());
        rows.push(cols);
      }
    }
    return {header, rows};
  }

  function validateSchema(header){
    const requiredHeaders = [
      "Project ID","Activity ID","Activity Name","Activity Type","At Completion Duration","Start","Finish",
      "Activity Status","Total Float","Primary Constraint","Predecessor Details","Predecessors",
      "Successor Details","Successors"
    ];
    for(let rh of requiredHeaders){
      if(!header.includes(rh)){
        throw new Error(`Missing required header: ${rh}`);
      }
    }
  }

  function loadCSV(text){
    try {
      const {header, rows} = parseCSV(text);
      validateSchema(header);
      csvDataRows = [header].concat(rows);
      log('INFO','VALIDATE_SCHEMA',`CSV schema validated. ${rows.length} data rows found.`);
      chkCsvParsed.checked = true;
      setAppState(STATES.CSV_LOADED);
      updateCsvInfo(`CSV loaded. Rows: ${rows.length}`);
    } catch(e){
      log('ERROR','VALIDATE_SCHEMA',e.message);
      updateCsvInfo(`Error: ${e.message}`);
    }
  }

  function updateCsvInfo(msg){
    csvInfo.textContent = msg;
  }

  function setAppState(newState){
    appState = newState;
    appStateSpan.textContent = newState;
    if(appState === STATES.CSV_LOADED){
      btnBuildGraph.disabled = false;
      btnAnalyze.disabled = true;
      btnExport.disabled = true;
    }
    else if(appState === STATES.GRAPH_BUILT){
      btnAnalyze.disabled = false;
      btnExport.disabled = true;
    }
    else if(appState === STATES.ANALYZED){
      btnExport.disabled = false;
    }
    else if(appState === STATES.EXPORT_READY){
      btnExport.disabled = false;
    }
    else {
      // IDLE
      btnBuildGraph.disabled = true;
      btnAnalyze.disabled = true;
      btnExport.disabled = true;
    }
  }

  // Graph building
  function buildGraph(){
    log('INFO','BUILD_GRAPH','Building graph...');
    cycleDetected = false;
    activityMap.clear();
    adjacencySuccessors.clear();
    adjacencyPredecessors.clear();
    edges = [];
    enumeratedPaths = [];

    const header = csvDataRows[0];
    const rows = csvDataRows.slice(1);
    const idxActivityID = header.indexOf("Activity ID");
    const idxDuration = header.indexOf("At Completion Duration");
    const idxStatus = header.indexOf("Activity Status");
    const idxPred = header.indexOf("Predecessors");
    const idxSucc = header.indexOf("Successors");

    let seenIDs = new Set();
    for(let i=0; i<rows.length; i++){
      const row = rows[i];
      if(row.length < header.length) {
        log('WARN','BUILD_GRAPH','Row has fewer columns than header');
        continue;
      }
      const actID = row[idxActivityID];
      if(!actID){
        log('ERROR','BUILD_GRAPH','Missing Activity ID, skipping row');
        continue;
      }
      if(seenIDs.has(actID)){
        log('WARN','BUILD_GRAPH',`Duplicate Activity ID ${actID} encountered; ignoring row`);
        continue;
      }
      seenIDs.add(actID);

      const rawDuration = parseFloat(row[idxDuration]);
      const statusRaw = row[idxStatus] ? row[idxStatus].trim().toLowerCase() : 'not started';
      let duration = (!isNaN(rawDuration)) ? rawDuration : 0;
      if(isNaN(rawDuration)){
        log('WARN','BUILD_GRAPH',`Invalid duration for ${actID}, defaulting to 0`);
      }
      let status = (statusRaw==='completed'||statusRaw==='in progress'||statusRaw==='not started')
                   ? statusRaw : 'not started';
      if(status!==statusRaw){
        log('WARN','BUILD_GRAPH',`Invalid/missing status for ${actID}, defaulting to 'not started'`);
      }

      activityMap.set(actID, {
        id: actID,
        duration,
        status,
        ES: null,
        EF: null,
        LS: null,
        LF: null
      });

      adjacencySuccessors.set(actID, []);
      adjacencyPredecessors.set(actID, []);
    }

    const fallbackMode = fallbackModeSelect.value;
    for(let i=0; i<rows.length; i++){
      const row = rows[i];
      if(row.length < header.length) continue;
      const actID = row[idxActivityID];
      if(!activityMap.has(actID)) continue;
      const rawPred = row[idxPred] || '';
      const rawSucc = row[idxSucc] || '';
      let preds = rawPred.split(/;|\|/).map(s=>s.trim()).filter(Boolean);
      let succs = rawSucc.split(/;|\|/).map(s=>s.trim()).filter(Boolean);

      // Link from each predecessor to this
      if(preds.length){
        preds.forEach(pid=>{
          if(!activityMap.has(pid)){
            if(pid){
              if(fallbackMode==='placeholder'){
                if(!activityMap.has(`<MISSING:${pid}>`)){
                  activityMap.set(`<MISSING:${pid}>`, {
                    id: `<MISSING:${pid}>`,
                    duration: 0,
                    status:'unknown',
                    ES:null, EF:null, LS:null, LF:null
                  });
                  adjacencySuccessors.set(`<MISSING:${pid}>`, []);
                  adjacencyPredecessors.set(`<MISSING:${pid}>`, []);
                }
                adjacencySuccessors.get(`<MISSING:${pid}>`).push(actID);
                adjacencyPredecessors.get(actID).push(`<MISSING:${pid}>`);
              } else {
                log('ERROR','BUILD_GRAPH',`Unknown predecessor ${pid} for ${actID}, ignoring edge`);
              }
            }
          } else {
            adjacencySuccessors.get(pid).push(actID);
            adjacencyPredecessors.get(actID).push(pid);
          }
        });
      }
      // Link from this to each successor
      if(succs.length){
        succs.forEach(sid=>{
          if(!activityMap.has(sid)){
            if(sid){
              if(fallbackMode==='placeholder'){
                if(!activityMap.has(`<MISSING:${sid}>`)){
                  activityMap.set(`<MISSING:${sid}>`, {
                    id: `<MISSING:${sid}>`,
                    duration: 0,
                    status:'unknown',
                    ES:null, EF:null, LS:null, LF:null
                  });
                  adjacencySuccessors.set(`<MISSING:${sid}>`, []);
                  adjacencyPredecessors.set(`<MISSING:${sid}>`, []);
                }
                adjacencySuccessors.get(actID).push(`<MISSING:${sid}>`);
                adjacencyPredecessors.get(`<MISSING:${sid}>`).push(actID);
              } else {
                log('ERROR','BUILD_GRAPH',`Unknown successor ${sid} for ${actID}, ignoring edge`);
              }
            }
          } else {
            adjacencySuccessors.get(actID).push(sid);
            adjacencyPredecessors.get(sid).push(actID);
          }
        });
      }
    }

    // Build edge list
    activityMap.forEach((val, key)=>{
      let succs = adjacencySuccessors.get(key) || [];
      succs.forEach(s => {
        edges.push({u:key, v:s, FF_edge:null});
      });
    });

    chkGraphBuilt.checked = true;
    setAppState(STATES.GRAPH_BUILT);
    cardActivitiesCount.textContent = activityMap.size;
    cardEdgesCount.textContent = edges.length;
  }

  // Cycle detection & Kahn's topological sort
  function topologicalSort(){
    log('INFO','TOPO_SORT','Performing topological sort...');
    let inDegree = new Map();
    activityMap.forEach((val,key)=>{
      inDegree.set(key, 0);
    });
    edges.forEach(e=>{
      inDegree.set(e.v, (inDegree.get(e.v)||0)+1);
    });
    let queue = [];
    inDegree.forEach((val,key)=>{ if(val===0) queue.push(key); });
    let sorted = [];
    while(queue.length){
      let n = queue.shift();
      sorted.push(n);
      (adjacencySuccessors.get(n)||[]).forEach(succ=>{
        let d = inDegree.get(succ)-1;
        inDegree.set(succ, d);
        if(d===0) queue.push(succ);
      });
    }
    if(sorted.length < activityMap.size){
      // not all nodes were sorted -> cycle
      cycleDetected = true;
      log('ERROR','TOPO_SORT','Cycle detected. Analysis blocked.');
      let cycleSample = [];
      activityMap.forEach((v,k)=>{ cycleSample.push(k); });
      cycleSample = cycleSample.slice(0,5);
      log('INFO','TOPO_SORT',`Sample cycle nodes: ${cycleSample.join(',')}`);
      return null;
    }
    return sorted;
  }

  // CPM Forward & Backward passes
  function forwardPass(topo) {
    log('INFO','FORWARD_PASS','Computing ES/EF...');
    // ES(i) = max(EF of predecessors), EF(i)=ES(i)+Dur(i)
    topo.forEach(n=>{
      let node = activityMap.get(n);
      let preds = adjacencyPredecessors.get(n) || [];
      let es = 0;
      for(let p of preds){
        let pNode = activityMap.get(p);
        if(pNode && pNode.EF!=null){
          if(pNode.EF>es) es=pNode.EF;
        }
      }
      node.ES = es;
      node.EF = es + node.duration;
    });
  }

  function backwardPass(topo) {
    log('INFO','BACKWARD_PASS','Computing LS/LF...');
    // PF = max(EF(i))
    let pf = 0;
    topo.forEach(n=>{
      let node = activityMap.get(n);
      if(node.EF>pf) pf=node.EF;
    });
    cpmProjectFinish = pf;
    // backward
    for(let i=topo.length-1;i>=0;i--){
      let n = topo[i];
      let node = activityMap.get(n);
      let succs = adjacencySuccessors.get(n) || [];
      if(succs.length===0){
        node.LF = pf;
      } else {
        let lf = Number.POSITIVE_INFINITY;
        succs.forEach(s=>{
          let sNode = activityMap.get(s);
          if(sNode && sNode.LS!=null && sNode.LS<lf) lf=sNode.LS;
        });
        if(lf===Number.POSITIVE_INFINITY) lf=pf;
        node.LF=lf;
      }
      node.LS=node.LF-node.duration;
    }
  }

  function computeFreeFloat(){
    log('INFO','FF_EDGES','Computing per-edge free float...');
    edges.forEach(e=>{
      let u = activityMap.get(e.u);
      let v = activityMap.get(e.v);
      if(u && v && u.EF!=null && v.ES!=null){
        e.FF_edge = v.ES - u.EF;
      } else {
        log('ERROR','FF_EDGES',`Cannot compute FF for edge ${e.u}->${e.v}`);
      }
    });
    chkFfComputed.checked = true;
  }

  // Backward Path Enumeration
  function enumeratePaths(startId){
    log('INFO','ENUMERATE_PATHS','Enumerating backward paths...');
    enumeratedPaths = [];
    analysisAborted = false;
    const maxPaths = parseInt(maxPathsInput.value,10) || 250;
    const maxDepth = parseInt(maxDepthInput.value,10) || 500;

    const stack = [{nid:startId, path:[startId], edges:[], totalFF:0}];
    let pathCount = 0;
    while(stack.length>0){
      if(analysisAborted) break;
      if(pathCount>=maxPaths){
        log('WARN','ENUMERATE_PATHS',`Max paths limit (${maxPaths}) reached, stopping.`);
        break;
      }
      const current = stack.pop();
      const currentNode = activityMap.get(current.nid);
      if(!currentNode){ 
        // placeholder or missing
        // stop if fallback placeholder
        enumeratedPaths.push({
          path: current.path.slice(),
          edges: current.edges.slice(),
          totalFF: current.totalFF,
          terminalID: current.nid
        });
        pathCount++;
        continue;
      }
      if(currentNode.status==='completed' && current.path.length>1){
        // terminal completed
        enumeratedPaths.push({
          path: current.path.slice(),
          edges: current.edges.slice(),
          totalFF: current.totalFF,
          terminalID: current.nid
        });
        pathCount++;
        continue;
      }
      if(currentNode.status==='completed' && current.path.length===1){
        // zero-edge path
        enumeratedPaths.push({
          path: [startId],
          edges: [],
          totalFF: 0,
          terminalID: startId
        });
        pathCount++;
        continue;
      }
      if(current.path.length>maxDepth){
        log('WARN','ENUMERATE_PATHS','Max depth reached, partial search only.');
        continue;
      }
      const preds = adjacencyPredecessors.get(current.nid)||[];
      if(preds.length===0){
        enumeratedPaths.push({
          path: current.path.slice(),
          edges: current.edges.slice(),
          totalFF: current.totalFF,
          terminalID: current.nid
        });
        pathCount++;
      } else {
        for(let p of preds){
          if(current.path.includes(p)) {
            // skip repeated node in the current path
            continue;
          }
          const eFF = findEdgeFF(p, current.nid) || 0;
          stack.push({
            nid: p,
            path: current.path.concat(p),
            edges: current.edges.concat({u:p,v:current.nid,ff:eFF}),
            totalFF: current.totalFF + eFF
          });
        }
      }
    }
    log('INFO','ENUMERATE_PATHS',`Total enumerated paths: ${enumeratedPaths.length}`);
    chkPathsFound.checked = (enumeratedPaths.length>0);
  }

  function findEdgeFF(u,v){
    let edgeObj = edges.find(e=>e.u===u && e.v===v);
    return edgeObj ? edgeObj.FF_edge : null;
  }

  // Ranking
  function rankPaths(){
    log('INFO','RANK_PATHS','Ranking paths...');
    enumeratedPaths.forEach(p=>{
      p.edgeCount = p.edges.length;
      p.idSequence = p.path.slice().reverse().join('>');
      p.bottleneckEdgeFF = null;
      if(p.edges.length>0){
        let minFF = Number.POSITIVE_INFINITY;
        for(let e of p.edges){
          if(e.ff<minFF) minFF=e.ff;
        }
        p.bottleneckEdgeFF = minFF;
      } else {
        p.bottleneckEdgeFF = 0;
      }
    });
    enumeratedPaths.sort((a,b)=>{
      // primary: totalFF asc
      if(a.totalFF!==b.totalFF) return a.totalFF-b.totalFF;
      // secondary: edgeCount asc
      if(a.edgeCount!==b.edgeCount) return a.edgeCount-b.edgeCount;
      // tertiary: lexicographic idSequence
      if(a.idSequence<b.idSequence) return -1;
      if(a.idSequence>b.idSequence) return 1;
      return 0;
    });
    for(let i=0; i<enumeratedPaths.length; i++){
      enumeratedPaths[i].rank = i+1;
    }
    chkPathsRanked.checked = true;
  }

  // Render top 3
  function renderTop3(){
    top3TableBody.innerHTML = '';
    let top3 = enumeratedPaths.slice(0,3);
    top3.forEach((p)=>{
      const row = document.createElement('tr');
      const totalFF = formatFF(p.totalFF);
      row.innerHTML = `
        <td>${p.rank}</td>
        <td>${totalFF}</td>
        <td>${p.edgeCount}</td>
        <td>${formatFF(p.bottleneckEdgeFF)}</td>
        <td>${p.terminalID}</td>
        <td>${p.path.slice().reverse().join('>')}</td>
      `;
      top3TableBody.appendChild(row);
    });
  }

  // Render full table
  function renderPathsTable(){
    pathsTableBody.innerHTML = '';
    enumeratedPaths.forEach(p=>{
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${p.rank}</td>
        <td>${formatFF(p.totalFF)}</td>
        <td>${p.edgeCount}</td>
        <td>${formatFF(p.bottleneckEdgeFF)}</td>
        <td>${p.terminalID}</td>
        <td>${p.path.slice().reverse().join('>')}</td>
        <td>${p.edges.map(e=>formatFF(e.ff)).join(';')}</td>
        <td></td>
      `;
      pathsTableBody.appendChild(row);
    });
  }

  function formatFF(ffVal){
    if(ffVal===null || ffVal===undefined) return 'N/A';
    const isHours = (unitsToggle.value==='hours');
    const hpd = parseFloat(hoursPerDayInput.value)||8;
    if(isHours){
      return (ffVal*hpd).toFixed(2);
    }
    return ffVal.toFixed(2);
  }

  // Export
  function doExport(){
    // Paths.csv
    let isAborted = (analysisAborted===true);
    let csvLines = ["Rank,TotalFF_Days,TotalFF_Hours,EdgesCount,BottleneckFF_Days,BottleneckEdge (u->v),TerminalCompletedID,PathIDs (Start->...->Terminal),PerEdgeFF_Days (semicolon),Aborted,Notes"];
    enumeratedPaths.forEach(p=>{
      let rank = p.rank;
      let tffDays = p.totalFF.toFixed(2);
      let hpd = parseFloat(hoursPerDayInput.value)||8;
      let tffHours = (p.totalFF*hpd).toFixed(2);
      let bottleneckDays = p.bottleneckEdgeFF.toFixed(2);
      let bottleneckEdge = "N/A";
      if(p.edges && p.edges.length>0){
        let minEd = p.edges.reduce((acc,cur)=>acc.ff<cur.ff?acc:cur);
        bottleneckEdge = `${minEd.u}->${minEd.v}`;
      }
      let termID = p.terminalID;
      let pathIDs = p.path.slice().reverse().join('>');
      let perEdgeDays = p.edges.map(e=>e.ff.toFixed(2)).join(';');
      csvLines.push(`${rank},${tffDays},${tffHours},${p.edgeCount},${bottleneckDays},${bottleneckEdge},${termID},${pathIDs},${perEdgeDays},${isAborted},`);
    });
    let pathsBlob = new Blob([csvLines.join('\n')], {type: 'text/csv'});
    let pathsUrl = URL.createObjectURL(pathsBlob);

    // Summary.csv - top 3
    let top3 = enumeratedPaths.slice(0,3);
    let sumLines = ["Rank,TotalFF_Days,TotalFF_Hours,EdgesCount,BottleneckFF_Days,BottleneckEdge (u->v),TerminalCompletedID,PathIDs (Start->...->Terminal),PerEdgeFF_Days (semicolon),Aborted,Notes"];
    top3.forEach(p=>{
      let rank = p.rank;
      let tffDays = p.totalFF.toFixed(2);
      let hpd = parseFloat(hoursPerDayInput.value)||8;
      let tffHours = (p.totalFF*hpd).toFixed(2);
      let bottleneckDays = p.bottleneckEdgeFF.toFixed(2);
      let bottleneckEdge = "N/A";
      if(p.edges && p.edges.length>0){
        let minEd = p.edges.reduce((acc,cur)=>acc.ff<cur.ff?acc:cur);
        bottleneckEdge = `${minEd.u}->${minEd.v}`;
      }
      let termID = p.terminalID;
      let pathIDs = p.path.slice().reverse().join('>');
      let perEdgeDays = p.edges.map(e=>e.ff.toFixed(2)).join(';');
      sumLines.push(`${rank},${tffDays},${tffHours},${p.edgeCount},${bottleneckDays},${bottleneckEdge},${termID},${pathIDs},${perEdgeDays},${isAborted},`);
    });
    let sumBlob = new Blob([sumLines.join('\n')], {type: 'text/csv'});
    let sumUrl = URL.createObjectURL(sumBlob);

    // AnalysisLog.txt
    let logFileLines = [];
    logEntries.forEach(le=>{
      logFileLines.push(`${le.timestamp} [${le.level}] [${le.step}] ${le.message}`);
    });
    let logBlob = new Blob([logFileLines.join('\n')], {type:'text/plain'});
    let logUrl = URL.createObjectURL(logBlob);

    // Download by creating anchor
    downloadFile(pathsUrl,"Paths.csv");
    downloadFile(sumUrl,"Summary.csv");
    downloadFile(logUrl,"AnalysisLog.txt");

    chkOutputsReady.checked = true;
  }

  function downloadFile(url, filename){
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // Analyze
  function analyzePaths(){
    let startID = startActivitySelect.value;
    if(!activityMap.has(startID)){
      log('ERROR','ANALYZE','Invalid start activity');
      return;
    }
    analysisAborted = false;
    let timeStart = performance.now();

    let topo = topologicalSort();
    if(!topo || cycleDetected){
      cardCycleDetected.textContent = "Yes";
      chkNoCycles.checked = false;
      return;
    } else {
      cardCycleDetected.textContent = "No";
      chkNoCycles.checked = true;
    }
    forwardPass(topo);
    backwardPass(topo);
    chkCpmTimes.checked = true;
    computeFreeFloat();
    enumeratePaths(startID);
    rankPaths();
    renderTop3();
    renderPathsTable();
    cardProjectFinish.textContent = `${cpmProjectFinish}`;
    let timeEnd = performance.now();
    cardAnalysisTime.textContent = (timeEnd-timeStart).toFixed(2);
    setAppState(STATES.ANALYZED);
  }

  // Cancel
  btnCancelStop.addEventListener('click',()=>{
    analysisAborted = true;
    log('WARN','USER','Analysis aborted by user');
  });

  // Reset
  btnReset.addEventListener('click',()=>{
    if(!confirm('Reset all state?')) return;
    location.reload();
  });

  // CSV load
  fileInput.addEventListener('change',(e)=>{
    const file = e.target.files[0];
    if(!file) return;
    if(file.size>10*1024*1024){
      log('WARN','LOAD_CSV','File is >10MB, might exceed recommended size');
    }
    const reader = new FileReader();
    reader.onload = function(ev){
      loadCSV(ev.target.result);
    };
    reader.readAsText(file);
  });
  btnLoadSample.addEventListener('click',()=>{
    loadCSV(sampleCSV);
  });

  // Build Graph
  btnBuildGraph.addEventListener('click',()=>{
    buildGraph();
    // populate startActivitySelect
    startActivitySelect.innerHTML = '';
    activityMap.forEach((v,k)=>{
      let opt = document.createElement('option');
      opt.value = k; 
      opt.textContent = k;
      startActivitySelect.appendChild(opt);
    });
  });

  // Analyze
  btnAnalyze.addEventListener('click',()=>{
    analyzePaths();
  });

  // Export
  btnExport.addEventListener('click',()=>{
    doExport();
    setAppState(STATES.EXPORT_READY);
  });

  // Log Panel
  btnToggleLog.addEventListener('click',()=>{
    logPanel.classList.toggle('visible');
    chkLogAvailable.checked = logPanel.classList.contains('visible');
  });

  // Download Log
  btnDownloadLog.addEventListener('click',()=>{
    let logFileLines = [];
    logEntries.forEach(le=>{
      logFileLines.push(`${le.timestamp} [${le.level}] [${le.step}] ${le.message}`);
    });
    let logBlob = new Blob([logFileLines.join('\n')], {type:'text/plain'});
    let logUrl = URL.createObjectURL(logBlob);
    downloadFile(logUrl,"AnalysisLog.txt");
  });

  // Theme toggle
  btnThemeToggle.addEventListener('click', toggleTheme);
  function toggleTheme(){
    let currentTheme = document.body.getAttribute('data-theme');
    let newTheme = (currentTheme==='light')?'dark':'light';
    document.body.setAttribute('data-theme', newTheme);
  }

  // Modals
  btnHelp.addEventListener('click',()=>{
    helpModal.classList.add('show');
    helpModal.setAttribute('aria-hidden','false');
  });
  btnSettings.addEventListener('click',()=>{
    settingsPanel.classList.toggle('hidden');
    // or show as modal
    // settingsModal.classList.add('show');
    // settingsModal.setAttribute('aria-hidden','false');
  });
  document.querySelectorAll('.closeModal').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      let targetId = e.target.getAttribute('data-close-modal');
      if(targetId==='helpModal'){
        helpModal.classList.remove('show');
        helpModal.setAttribute('aria-hidden','true');
      } else if(targetId==='settingsModal'){
        settingsModal.classList.remove('show');
        settingsModal.setAttribute('aria-hidden','true');
      }
    });
  });

  // Self-test
  btnSelfTest.addEventListener('click',()=>{
    log('INFO','SELF_TEST','Running self-test with embedded sample...');
    loadCSV(sampleCSV);
    setTimeout(()=>{
      buildGraph();
      setTimeout(()=>{
        if(activityMap.size<=0){
          log('ERROR','SELF_TEST','Graph is empty, failing test');
          return;
        }
        startActivitySelect.value = 'A4'; 
        analyzePaths();
        setTimeout(()=>{
          if(enumeratedPaths.length>0){
            log('SUCCESS','SELF_TEST','Found paths, test PASS');
          } else {
            log('ERROR','SELF_TEST','No paths found, test FAIL');
          }
        },200);
      },200);
    },200);
  });

  // Keyboard shortcuts
  document.addEventListener('keydown',(e)=>{
    if(e.key==='?'){
      helpModal.classList.add('show');
      helpModal.setAttribute('aria-hidden','false');
    }
    if(e.key==='t'){
      toggleTheme();
    }
    if(e.key==='g'){
      if(!btnBuildGraph.disabled) buildGraph();
    }
    if(e.key==='a'){
      if(!btnAnalyze.disabled) analyzePaths();
    }
    if(e.key==='e'){
      if(!btnExport.disabled) doExport();
    }
    if(e.key==='l'){
      logPanel.classList.toggle('visible');
      chkLogAvailable.checked = logPanel.classList.contains('visible');
    }
  });

  // On load
  buildDateSpan.textContent = (new Date()).toLocaleString();

  // Initialization
  setAppState(STATES.IDLE);
})();
</script>
</body>
</html>
