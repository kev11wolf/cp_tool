<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>P6 XLSX Backward Tracer (Large Datasets) â€“ Integrated</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg: #fff; --ink: #111; --muted:#555; --card:#f9f9f9; }
    body { font-family: Arial, sans-serif; margin:0; padding:0; background: var(--bg); color: var(--ink); }
    .container { max-width: 1100px; margin: 0 auto; padding: 20px; }
    .panel { background: #fff; border: 1px solid #e5e5e5; border-radius: 8px; padding: 16px; margin-bottom: 14px; box-shadow: 0 2px 6px rgba(0,0,0,.04); }
    h1 { font-size: 1.4rem; margin: 0 0 8px; }
    label { font-weight: 600; display: block; margin: 8px 0 6px; }
    input[type="text"], input[type="file"] { width: 100%; padding: 8px 10px; border: 1px solid #ccc; border-radius: 6px; box-sizing: border-box; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; align-items: end; }
    button { padding: 10px 14px; border: none; border-radius: 6px; cursor: pointer; }
    .btn { background: #007bff; color: #fff; }
    .btn.secondary { background: #6c757d; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }
    #results { margin-top: 10px; }
    table { width: 100%; border-collapse: collapse; margin-top: 6px; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; }
    th { background: #f6f6f6; }
    #log { margin-top: 8px; height: 140px; overflow: auto; background: #f7f7f7; border: 1px solid #ddd; padding: 8px; font-family: monospace; white-space: pre-wrap; }
    .hint { color: var(--muted); font-size: .88em; }
  </style>
</head>
<body>
  <div class="container">
    <h1>P6 XLSX Backward Tracer (Large Datasets) - Integrated</h1>

    <!-- File Upload -->
    <div class="panel">
      <label for="fileInput">Upload Excel file (xlsx, xls, xlsm):</label>
      <input id="fileInput" type="file" accept=".xlsx,.xls,.xlsm" />
      <div class="hint" style="margin-top:6px;">
        Supports large datasets via in-memory batching inspiration. Uses SheetJS (XLSX).
      </div>
    </div>

    <!-- Controls -->
    <div class="panel row" style="align-items: end;">
      <div>
        <label for="startActivity">Start Activity ID (Backward Trace)</label>
        <input id="startActivity" type="text" placeholder="e.g., A-Start" />
      </div>
      <div style="display:flex; gap:8px;">
        <button class="btn" id="runBtn" disabled>Run Backward Trace</button>
        <button class="btn secondary" id="exportBtn" disabled>Export CSV</button>
      </div>
    </div>

    <!-- Results -->
    <div class="panel" id="resultsPanel">
      <h3 style="margin:0 0 8px;">Results (Top Paths)</h3>
      <div id="results" style="min-height:60px;"></div>
    </div>

    <!-- Log -->
    <div class="panel">
      <h3 style="margin:0 0 8px;">Log</h3>
      <div id="log"></div>
    </div>
  </div>

  <!-- Load SheetJS (XLSX) from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>

  <script>
    (function() {
      // DOM references
      const fileInput = document.getElementById('fileInput');
      const runBtn = document.getElementById('runBtn');
      const exportBtn = document.getElementById('exportBtn');
      const startActivityInput = document.getElementById('startActivity');
      const resultsDiv = document.getElementById('results');
      const logDiv = document.getElementById('log');
      const resultsPanel = document.getElementById('resultsPanel');

      // State
      let workbookData = [];  // array of row objects from sheet_to_json
      let headers = [];         // detected headers (column names)
      let graph = {};             // id -> preds array
      let paths = [];             // array of paths (each path is array of ids)

      // Logging helper
      function log(msg) {
        const t = new Date().toISOString();
        logDiv.textContent += `[${t}] ${msg}\n`;
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      // Utility: clear results
      function clearResults() {
        resultsDiv.innerHTML = '';
        resultsPanel.style.display = 'block';
        paths = [];
        graph = {};
        workbookData = [];
        headers = [];
      }

      // Guard: ensure XLSX is loaded
      function ensureXLSXLoaded() {
        if (typeof XLSX === 'undefined') {
          log('Error: XLSX library is not loaded. Check network or CSP.');
          alert('XLSX library did not load. Check network or CSP settings.');
          return false;
        }
        return true;
      }

      // Header detection: heuristic based on header names
      function detectHeadersFromRows(rows) {
        if (!rows || rows.length === 0) return [];
        const candidate = Object.keys(rows[0] || {});
        const likely = [
          'id','activity','name','task','desc','description','start','finish','duration','dur','days',
          'predecessor','pre','pred','dep','dependencies','predecessors','successor','succ','succs','dependencies'
        ];
        const detected = candidate.filter(c => {
          const lc = String(c).toLowerCase();
          return likely.some(n => lc.includes(n));
        });
        if (detected.length === 0) return candidate.slice(0, 6);
        return detected;
      }

      // Graph construction: map each row to its predecessors
      // We consider columns that include 'pred' or 'dependencies' as sources of preds
      function buildGraph(rows, hdrs) {
        const g = {};
        const idCol = hdrs.find(h => String(h).toLowerCase().includes('id')) || 'ID';
        const predCols = hdrs.filter(h => String(h).toLowerCase().includes('pred') || String(h).toLowerCase().includes('dependencies'));
        rows.forEach(r => {
          const id = r[idCol] ?? r['ID'] ?? r['Id'] ?? '';
          let preds = [];
          predCols.forEach(pc => {
            const val = r[pc];
            if (val) {
              preds = preds.concat(String(val).split(/[;,|]+/).map(s => s.trim()).filter(Boolean));
            }
          });
          // Trim duplicates
          preds = Array.from(new Set(preds));
          g[id] = preds;
        });
        return g;
      }

      // Backward path tracing: DFS from startId to accumulate paths
      function traceBackward(graph, startId, maxDepth = 2000) {
        const results = [];
        const stack = [[startId, [startId]]];
        while (stack.length) {
          const [node, path] = stack.pop();
          const preds = graph[node] || [];
          if (!preds.length || path.length > maxDepth) {
            results.push(path);
            continue;
          }
          preds.forEach(p => stack.push([p, path.concat(p)]));
        }
        results.sort((a, b) => b.length - a.length);
        return results;
      }

      // CSV export: paths as rows with steps
      function pathsToCSV(paths) {
        const maxLen = paths.reduce((m, p) => Math.max(m, p.length), 0);
        const lines = [];
        lines.push(Array.from({ length: maxLen }).map((_, i) => `Step_${i+1}`).join(','));
        for (const p of paths) {
          const row = Array.from({ length: maxLen }).map((_, i) => p[i] ?? '');
          lines.push(row.join(','));
        }
        return lines.join('\n');
      }

      // File input handler
      fileInput.addEventListener('change', async (e) => {
        clearResults();
        const file = e.target.files?.[0];
        if (!file) return;

        if (!ensureXLSXLoaded()) return;

        try {
          const data = await file.arrayBuffer();
          log('Reading workbook with XLSX...');
          const wb = XLSX.read(data, { type: 'array' });

          // Use first sheet
          const firstSheetName = wb.SheetNames[0];
          const ws = wb.Sheets[firstSheetName];

          // Convert to JSON
          const json = XLSX.utils.sheet_to_json(ws, { defval: '' });
          workbookData = json;

          // Detect headers
          if (json.length > 0) {
            headers = detectHeadersFromRows(json);
          } else {
            headers = Object.keys(json[0] ?? {});
          }

          log(`Parsed rows: ${json.length}. Detected headers: ${headers.join(', ') || '(none)'}`);
          runBtn.disabled = false;
          exportBtn.disabled = true;

          // Optional: show a quick preview in results
          if (json.length > 0) {
            const preview = json.slice(0, 5);
            const tbl = document.createElement('table');
            const thead = document.createElement('thead');
            const tr = document.createElement('tr');
            (headers.length ? headers : Object.keys(preview[0] ?? {})).forEach(h => {
              const th = document.createElement('th');
              th.textContent = h;
              tr.appendChild(th);
            });
            thead.appendChild(tr);
            tbl.appendChild(thead);
            const tbody = document.createElement('tbody');
            preview.forEach(row => {
              const trr = document.createElement('tr');
              (headers.length ? headers : Object.keys(row)).forEach(k => {
                const td = document.createElement('td');
                td.textContent = row[k] ?? '';
                trr.appendChild(td);
              });
              tbody.appendChild(trr);
            });
            tbl.appendChild(tbody);
            resultsDiv.innerHTML = '';
            resultsDiv.appendChild(tbl);
          }
        } catch (err) {
          log(`Error while parsing workbook: ${err?.message || err}`);
          console.error(err);
        }
      });

      // Run button: build graph and trace
      runBtn.addEventListener('click', () => {
        if (!workbookData || workbookData.length === 0) {
          log('No data loaded. Please upload a valid Excel file.');
          return;
        }
        const startIdRaw = (startActivityInput.value ?? '').trim();
        if (!startIdRaw) {
          log('Please specify a Start Activity ID to trace backward.');
          return;
        }

        // Build graph from data
        const idHint = headers.find(h => String(h).toLowerCase().includes('id')) ?? 'ID';
        const graphLocal = buildGraph(workbookData, headers);

        // If startId not present, warn but proceed with available keys
        if (!Object.values(graphLocal).some(arr => arr.includes(startIdRaw)) && !graphLocal[startIdRaw]) {
          log(`Warning: Start Activity ID "${startIdRaw}" not found in data. Proceeding with available graph data.`);
        }

        paths = traceBackward(graphLocal, startIdRaw);
        resultsDiv.innerHTML = '';

        if (!paths.length) {
          resultsDiv.textContent = 'No backward paths found for the given Start Activity.';
        } else {
          const ul = document.createElement('ul');
          paths.forEach((p, idx) => {
            const li = document.createElement('li');
            li.textContent = `Path ${idx + 1}: ${p.join(' -> ')}`;
            ul.appendChild(li);
          });
          resultsDiv.appendChild(ul);
        }

        exportBtn.disabled = paths.length === 0;
        log(`Found ${paths.length} backward path(s).`);
      });

      // Export CSV
      exportBtn.addEventListener('click', () => {
        if (!paths || paths.length === 0) {
          log('No paths to export.');
          return;
        }
        const csv = pathsToCSV(paths);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'backward_paths.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        log('Exported backward_paths.csv');
      });

      // Initial status
      log('Awaiting file upload. XLSX library loaded.');
      if (typeof XLSX === 'undefined') {
        log('Note: XLSX is not yet defined. If you see this message, the library might be blocked by CSP or still loading.');
      }

      // Optional: auto-hide zero-state areas or enhance UX with a progress indicator in large datasets
    })();
  </script>
</body>
</html>
