<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Critical Path Finder — CSV Only (Computes Free Float)</title>
<style>
  :root {
    --bg: #ffffff; --fg: #111; --muted: #666;
    --panel: #f6f8fa; --border: #e1e4e8; --accent: #0b5fff;
  }
  body { font-family: Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; color: var(--fg); background: var(--bg); }
  h1 { margin-top: 0; }
  .row { margin: 0.75rem 0; }
  input[type="text"], select { padding: 0.45rem; }
  input[type="text"] { width: 360px; }
  button { padding: 0.5rem 0.9rem; margin-right: 0.5rem; cursor: pointer; }
  #log { white-space: pre-wrap; background: var(--panel); border: 1px solid var(--border); padding: 0.75rem; border-radius: 6px; min-height: 6rem; }
  .muted { color: var(--muted); font-size: 0.9rem; }
  .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(230px, 1fr)); gap: 0.75rem; }
  label { font-weight: 600; display: block; margin-bottom: 0.25rem; }
  .small { font-size: 0.9rem; }
</style>
</head>
<body>
  <h1>Critical Path Finder — CSV Only (Computes Free Float)</h1>

  <div class="row controls">
    <div>
      <label for="fileInput">CSV File (.csv)</label>
      <input id="fileInput" type="file" accept=".csv" />
      <div class="muted small">Everything runs locally in your browser.</div>
    </div>

    <div>
      <label for="startId">Starting Activity ID</label>
      <input id="startId" type="text" placeholder="Enter an Activity ID from the CSV" />
    </div>

    <div>
      <label for="unitSelect">Time Unit for FF & Lags</label>
      <select id="unitSelect">
        <option value="days" selected>Days</option>
        <option value="hours">Hours</option>
      </select>
      <div class="muted small">Lag strings with explicit units (e.g., +8h) are respected.</div>
    </div>

    <div>
      <label for="dateLocale">Date Format (Start/Finish)</label>
      <select id="dateLocale">
        <option value="us" selected>US — MM/DD/YYYY [HH:MM]</option>
        <option value="intl">Intl — DD/MM/YYYY [HH:MM]</option>
        <option value="auto">Auto (try multiple patterns)</option>
      </select>
      <div class="muted small">Also supports “DD-MMM-YYYY” (e.g., 05-Jan-2025 08:00).</div>
    </div>
  </div>

  <div class="row">
    <button id="runBtn">Run Analysis</button>
    <button id="resetBtn">Reset</button>
    <button id="downloadBtn" disabled>Download Results (CSV)</button>
  </div>

  <div class="row">
    <strong>Notes</strong>
    <ul class="small">
      <li>Traverses <em>predecessors</em> only (backward). Cycles are detected and handled.</li>
      <li>Per‑edge Free Float is computed from <code>Start</code>/<code>Finish</code> and relationship + lag from <code>Predecessor Details</code>.</li>
      <li>If only <code>Predecessors</code> (IDs) exist, edges are assumed <code>FS + 0</code>.</li>
      <li>Top 10 paths with the lowest sum of per‑edge Free Float are returned.</li>
    </ul>
  </div>

  <h3>Log</h3>
  <div id="log">Load a CSV, enter a Starting Activity ID, configure options, then click “Run Analysis”.</div>

<script>
/* ========================== CSV Parsing ========================== */
function parseCSV(text, delimiter = ",") {
  const rows = [];
  let row = [];
  let val = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i], n = text[i+1];
    if (inQuotes) {
      if (c === '"') {
        if (n === '"') { val += '"'; i++; }
        else { inQuotes = false; }
      } else { val += c; }
    } else {
      if (c === '"') inQuotes = true;
      else if (c === delimiter) { row.push(val); val = ""; }
      else if (c === "\r") { /* ignore */ }
      else if (c === "\n") { row.push(val); rows.push(row); row = []; val = ""; }
      else { val += c; }
    }
  }
  row.push(val);
  rows.push(row);
  if (rows.length && rows[rows.length-1].length === 1 && rows[rows.length-1][0] === "") rows.pop();
  return rows;
}
function rowsToObjects(rows) {
  if (!rows || rows.length === 0) return { headersRaw: [], headersKey: [], records: [] };
  const headersRaw = rows[0].map(h => (h ?? "").toString().trim());
  const headersKey = headersRaw.map(h => h.toLowerCase());
  const records = [];
  for (let r = 1; r < rows.length; r++) {
    const obj = {};
    for (let c = 0; c < headersRaw.length; c++) {
      const k = headersRaw[c];
      obj[k] = (rows[r][c] ?? "").toString();
      obj["__" + k.toLowerCase()] = (rows[r][c] ?? "").toString();
    }
    records.push(obj);
  }
  return { headersRaw, headersKey, records };
}
function resolveColumn(headersKey, headersRaw, candidates) {
  for (const cand of candidates) {
    const idx = headersKey.indexOf(cand.toLowerCase());
    if (idx !== -1) return headersRaw[idx];
  }
  return null;
}

/* ========================== Date Parsing ========================== */
function parseDateFlexible(s, localePref = "us") {
  if (!s) return null;
  const str = s.trim();
  if (!str) return null;

  // ISO / native parse
  const t = Date.parse(str);
  if (!Number.isNaN(t)) return new Date(t);

  // Patterns: US or Intl slashes
  const slashRe = /^(\d{1,2})\/\-\/\-(?: T:(\d{2})(?::(\d{2}))?)?$/;
  const mSlash = slashRe.exec(str);
  if (mSlash) {
    let a = parseInt(mSlash[1],10), b = parseInt(mSlash[2],10), y = parseInt(mSlash[3],10);
    if (y < 100) y += 2000;
    let M, D;
    if (localePref === "intl") { D = a; M = b; }
    else { M = a; D = b; } // default US
    const hh = parseInt(mSlash[4] || "0",10), mm = parseInt(mSlash[5] || "0",10), ss = parseInt(mSlash[6] || "0",10);
    return new Date(y, M-1, D, hh, mm, ss);
  }

  // Patterns: 05-Jan-2025 08:00 or 5-Jan-25
  const monMap = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11};
  const dashMon = /^(\d{1,2})- - (?: T:(\d{2})(?::(\d{2}))?)?$/;
  const mDash = dashMon.exec(str);
  if (mDash) {
    const D = parseInt(mDash[1],10);
    const mon = monMap[mDash[2].toLowerCase()];
    if (mon != null) {
      let y = parseInt(mDash[3],10); if (y < 100) y += 2000;
      const hh = parseInt(mDash[4] || "0",10), mm = parseInt(mDash[5] || "0",10), ss = parseInt(mDash[6] || "0",10);
      return new Date(y, mon, D, hh, mm, ss);
    }
  }

  // Fallback: try flipping locale if auto
  if (localePref === "auto") {
    return parseDateFlexible(str, "us") || parseDateFlexible(str, "intl");
  }

  return null;
}

/* ====================== Relationship & Lag Parsing ====================== */
function parsePredDetails(detailsStr) {
  // Returns array of { predId, type, lagVal, lagUnitRaw }
  // Accepts: "A100 FS+2d; A200 SS-8h", "B10", "C30FF-1d"
  if (!detailsStr) return [];
  const items = detailsStr.split(/[,;\n]+/).map(x => x.trim()).filter(Boolean);
  const out = [];
  for (const it of items) {
    // ID is first token up to whitespace or '('
    const idMatch = it.match(/^[^\s()]+/);
    const predId = idMatch ? idMatch[0].trim() : it;

    // Relationship type
    const relMatch = it.match(/\b(FS|SS|FF|SF)\b/i);
    const type = relMatch ? relMatch[1].toUpperCase() : "FS";

    // Lag (e.g., +2d, -8h, +1.5, -90m)
    const lagMatch = it.match(/([+-]\s*\d*\.?\d*\s*(?:d|h|m)?)/i);
    let lagVal = 0, lagUnitRaw = null;
    if (lagMatch) {
      const raw = lagMatch[1].replace(/\s+/g,"");
      const unitM = raw.match(/[dhm]$/i);
      lagUnitRaw = unitM ? unitM[0].toLowerCase() : null;
      const num = raw.replace(/[dhm]/ig,"");
      lagVal = parseFloat(num);
      if (Number.isNaN(lagVal)) lagVal = 0;
    }
    out.push({ predId, type, lagVal, lagUnitRaw });
  }
  return out;
}
function parsePredecessorIDs(simpleStr) {
  if (!simpleStr) return [];
  return simpleStr.split(/[,;]+/).map(s => (s || "").trim()).filter(Boolean).map(id => ({
    predId: id, type: "FS", lagVal: 0, lagUnitRaw: null
  }));
}

/* ============================= Model Build ============================= */
function buildModel(csvObj, opts) {
  const { headersRaw, headersKey, records } = csvObj;
  const idCol     = resolveColumn(headersKey, headersRaw, ["Activity ID"]);
  const startCol  = resolveColumn(headersKey, headersRaw, ["Start"]);
  const finishCol = resolveColumn(headersKey, headersRaw, ["Finish"]);
  const predDetailsCol = resolveColumn(headersKey, headersRaw, ["Predecessor Details"]);
  const predsCol       = resolveColumn(headersKey, headersRaw, ["Predecessors"]);

  if (!idCol)     throw new Error('Required column "Activity ID" not found.');
  if (!startCol)  throw new Error('Required column "Start" not found.');
  if (!finishCol) throw new Error('Required column "Finish" not found.');
  if (!predDetailsCol && !predsCol) {
    throw new Error('Required column "Predecessor Details" or "Predecessors" not found.');
  }

  // Build nodes
  const nodes = new Map(); // id -> { id, ES, EF, startStr, finishStr }
  for (const r of records) {
    const id = (r[idCol] ?? "").trim();
    if (!id) continue;
    const startStr = r[startCol] ?? "";
    const finishStr = r[finishCol] ?? "";
    const ES = parseDateFlexible(startStr, opts.dateLocale);
    const EF = parseDateFlexible(finishStr, opts.dateLocale);
    nodes.set(id, { id, ES, EF, startStr, finishStr });
  }

  // Build predecessor relationships for each successor
  const predMap = new Map(); // succId -> array of { predId, type, lagVal, lagUnitRaw }
  for (const r of records) {
    const succId = (r[idCol] ?? "").trim();
    if (!succId) continue;
    let arr = [];
    if (predDetailsCol && r[predDetailsCol]) {
      arr = parsePredDetails(r[predDetailsCol]);
    } else if (predsCol && r[predsCol]) {
      arr = parsePredecessorIDs(r[predsCol]);
    }
    // Filter entries that at least have an ID
    arr = arr.filter(x => !!x.predId);
    if (arr.length) predMap.set(succId, arr);
  }

  return { nodes, predMap };
}

/* ========================= Free Float Computation ========================= */
function unitToMs(unitSel) {
  return unitSel === "hours" ? 3600_000 : 86_400_000; // hours or days
}
function lagToMs(lagVal, lagUnitRaw, unitSel) {
  if (!lagVal) return 0;
  if (!lagUnitRaw) {
    // No explicit unit -> assume selected unit
    return lagVal * unitToMs(unitSel);
  }
  switch (lagUnitRaw) {
    case 'd': return lagVal * 86_400_000;
    case 'h': return lagVal * 3_600_000;
    case 'm': return lagVal * 60_000;
    default:  return lagVal * unitToMs(unitSel);
  }
}
function edgeFreeFloat(predNode, succNode, relType, lagVal, lagUnitRaw, unitSel) {
  const oneUnitMs = unitToMs(unitSel);
  const lagMs = lagToMs(lagVal, lagUnitRaw, unitSel);

  const ES_P = predNode?.ES || null;
  const EF_P = predNode?.EF || null;
  const ES_S = succNode?.ES || null;
  const EF_S = succNode?.EF || null;

  // Determine base and target timestamps per relationship
  let base = null, target = null;
  switch ((relType || "FS").toUpperCase()) {
    case "SS": base = ES_P; target = ES_S; break;
    case "FF": base = EF_P; target = EF_S; break;
    case "SF": base = ES_P; target = EF_S; break;
    case "FS":
    default:   base = EF_P; target = ES_S; break;
  }

  if (!base || !target) {
    return { ffUnits: 0, ms: 0, missingDates: true };
  }

  const ms = target.getTime() - (base.getTime() + lagMs);
  return { ffUnits: ms / oneUnitMs, ms, missingDates: false };
}

/* =============================== DFS / Paths =============================== */
function dfsPaths(model, startId, unitSel, maxPaths = 50000) {
  const { nodes, predMap } = model;
  if (!nodes.has(startId)) throw new Error(`Starting Activity ID "${startId}" not found in file.`);

  const results = [];
  const path = []; // sequence of edges: { succId, predId, type, lagVal, lagUnitRaw, ffUnits, flags }

  const visited = new Set(); // to detect cycles by Activity ID

  function dfs(currSuccId) {
    if (results.length >= maxPaths) return;

    const preds = predMap.get(currSuccId) || [];
    if (visited.has(currSuccId)) {
      // cycle – output the path as it stands with a cycle marker on a dummy edge
      path.push({ succId: currSuccId, predId: "(cycle)", type: "FS", lagVal: 0, lagUnitRaw: null, ffUnits: 0, flags: { cycle: true } });
      results.push([...path]);
      path.pop();
      return;
    }

    visited.add(currSuccId);

    if (preds.length === 0) {
      // Reached a start (no predecessors)
      results.push([...path]);
    } else {
      for (const rel of preds) {
        const predId = rel.predId;
        const predNode = nodes.get(predId) || null;
        const succNode = nodes.get(currSuccId) || null;

        const ff = edgeFreeFloat(predNode, succNode, rel.type, rel.lagVal, rel.lagUnitRaw, unitSel);
        path.push({
          succId: currSuccId,
          predId,
          type: (rel.type || "FS").toUpperCase(),
          lagVal: rel.lagVal || 0,
          lagUnitRaw: rel.lagUnitRaw || null,
          ffUnits: ff.ffUnits,
          flags: { missingDates: ff.missingDates, unknownPred: !predNode }
        });

        // Recurse into predecessor
        dfs(predId);

        path.pop();
      }
    }

    visited.delete(currSuccId);
  }

  dfs(startId);
  return results;
}

/* ============================ Ranking & Export ============================ */
function rankPathsByFF(paths) {
  return paths
    .map((edges, idx) => {
      const score = edges.reduce((acc, e) => acc + (Number(e.ffUnits) || 0), 0);
      return { idx, edges, score };
    })
    .sort((a, b) => a.score - b.score)
    .slice(0, 10);
}

function toCSV(rows) {
  const esc = v => {
    const s = (v ?? "").toString();
    return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
  };
  return rows.map(r => r.map(esc).join(",")).join("\n");
}
function downloadCSV(filename, text) {
  const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement("a"), { href: url, download: filename });
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
}

/* ================================ UI Logic ================================ */
const fileInput   = document.getElementById("fileInput");
const startIdInput= document.getElementById("startId");
const unitSelect  = document.getElementById("unitSelect");
const dateLocale  = document.getElementById("dateLocale");
const runBtn      = document.getElementById("runBtn");
const resetBtn    = document.getElementById("resetBtn");
const downloadBtn = document.getElementById("downloadBtn");
const logEl       = document.getElementById("log");

let lastResults = null; // ranked paths
let lastUnitSel = "days";

function log(msg) { logEl.textContent = msg; }

runBtn.addEventListener("click", () => {
  const file = fileInput.files && fileInput.files[0];
  if (!file) return log("Please choose a .csv file first.");
  const startId = (startIdInput.value || "").trim();
  if (!startId) return log("Please enter a Starting Activity ID.");

  const unitSel = unitSelect.value; // "days" or "hours"
  const localeSel = dateLocale.value; // "us" | "intl" | "auto"

  const reader = new FileReader();
  reader.onerror = () => log("Failed to read the CSV. Please try again.");
  reader.onload = () => {
    try {
      const text = reader.result.toString();
      const rows = parseCSV(text, ",");
      const csvObj = rowsToObjects(rows);
      const model = buildModel(csvObj, { dateLocale: localeSel });

      const allPaths = dfsPaths(model, startId, unitSel, 100000);
      if (allPaths.length === 0) {
        log(`No predecessor paths found starting from "${startId}".`);
        lastResults = null;
        downloadBtn.disabled = true;
        return;
      }

      const ranked = rankPathsByFF(allPaths);
      lastResults = ranked;
      lastUnitSel = unitSel;

      // Build preview
      const u = unitSel === "hours" ? "h" : "d";
      let preview = `Computed ${allPaths.length} path(s). Showing Top ${ranked.length} by lowest total Free Float:\n\n`;
      ranked.forEach((item, i) => {
        // Represent as S <- P1(ff) <- P2(ff) ...
        const seq = [];
        let currSucc = item.edges[0]?.succId || startId;
        seq.push(currSucc);
        for (const e of item.edges) {
          seq.push(`${e.predId} (ff=${(e.ffUnits).toFixed(2)}${u}${e.flags.missingDates ? ", *dates?" : ""})`);
        }
        preview += `#${i+1}  Score=${item.score.toFixed(2)}${u}  Path: ${seq.join(" <- ")}\n`;
      });
      preview += `\n* “ff” is per-edge Free Float in ${u}. “*dates?” marks edges where Start/Finish were missing.`;
      log(preview);
      downloadBtn.disabled = false;
    } catch (e) {
      console.error(e);
      log("Error: " + (e && e.message ? e.message : e));
      lastResults = null;
      downloadBtn.disabled = true;
    }
  };
  reader.readAsText(file, "utf-8");
});

downloadBtn.addEventListener("click", () => {
  if (!lastResults) return;
  const u = lastUnitSel === "hours" ? "h" : "d";

  // Build detailed rows
  const rows = [[
    "Path","Rank","Order",
    "Successor ID","Predecessor ID","Rel Type","Lag (raw)",
    `FF (${u})`,"Cumulative FF",
    "MissingDates","UnknownPred"
  ]];

  lastResults.forEach((item, rankIdx) => {
    let cum = 0;
    item.edges.forEach((e, orderIdx) => {
      const ff = Number(e.ffUnits) || 0;
      cum += ff;
      rows.push([
        `Path_${rankIdx+1}`, rankIdx+1, orderIdx+1,
        e.succId, e.predId, e.type,
        (e.lagVal ? (e.lagVal + (e.lagUnitRaw || u)) : "0"),
        ff.toFixed(4), cum.toFixed(4),
        e.flags.missingDates ? "Y" : "",
        e.flags.unknownPred ? "Y" : ""
      ]);
    });
    // If a path is length 0 (no predecessors), still output a header row for traceability
    if (item.edges.length === 0) {
      rows.push([`Path_${rankIdx+1}`, rankIdx+1, 1, item.succId || "", "", "", "0", "0", "0", "", ""]);
    }
  });

  downloadCSV("critical_paths_free_float.csv", toCSV(rows));
});

resetBtn.addEventListener("click", () => {
  fileInput.value = "";
  startIdInput.value = "";
  lastResults = null;
  downloadBtn.disabled = true;
  log("Load a CSV, enter a Starting Activity ID, configure options, then click “Run Analysis”.");
});
</script>
</body>
</html>
