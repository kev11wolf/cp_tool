<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>P6 XLSX Backward Tracer (Large Datasets) - Lite Mode</title>
  <style>
    /* Sexy neutral theme with drop shadows */
    :root {
      --bg: #f6f7f9;
      --card: #ffffff;
      --card2: #ffffff;
      --text: #1e293b;
      --muted: #64748b;
      --accent: #374151;
      --accent2: #4b5563;
      --shadow: 0 8px 24px rgba(0,0,0,.08);
      --radius: 14px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      font-family: Inter, ui-sans-serif, system-ui, -apple-system;
      background: linear-gradient(135deg, #f6f7fb 0%, #eef1f7 100%);
      color: var(--text);
      margin: 0;
      padding: 28px;
    }

    h1 { font-size: 1.6rem; margin: 0 0 8px; color: var(--accent); text-shadow: 0 1px 0 #fff; }
    .section {
      margin-bottom: 20px;
      padding: 16px;
      border-radius: var(--radius);
      background: white;
      box-shadow: var(--shadow);
      border: 1px solid #eef2f7;
    }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    input[type="file"] { padding: 8px; }
    select, button, input[type="text"] { padding: 9px 12px; font-size: 14px; border-radius: 8px; border: 1px solid #e5e7eb; background: #fff; }
    button { cursor: pointer; background: linear-gradient(#4f46e5, #4338ca); color: #fff; border: none; padding: 10px 14px; border-radius: 8px; box-shadow: 0 4px 10px rgba(67, 56, 202, .3); }
    button.secondary { background: linear-gradient(#64748b, #475569); }
    .hidden { display: none; }

    /* Tables + layout polish */
    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { border: 1px solid #e2e8f0; padding: 8px; text-align: left; font-family: inherit; }
    th { background: #f3f4f6; font-weight: 600; color: #374151; }
    #colMap { list-style: none; padding-left: 0; margin: 0; }
    #colMap li { margin: 4px 0; font-family: ui-monospace,SFMono-Regular,Monaco,Consolas,"Liberation Mono"; font-size: 12px; }

    /* Progress indicator styling */
    .progress {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.04);
      color: #0f172a;
      min-width: 120px;
      text-align: center;
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #e5e7eb;
      color: #374151;
      font-size: 12px;
      margin-left: 8px;
    }

    /* Responsive tweaks */
    @media (max-width: 800px) {
      .row { gap: 8px; }
      table, .section { width: 100%; }
    }
    /* Small helper to visually separate sections */
    .sep { height: 1px; background: #eef2f7; margin: 12px 0; border: 0; }
  </style>
</head>
<body>
  <h1>P6 XLSX Backward Tracer (Large Datasets) - Lite Mode</h1>

  <!-- Intro / File load -->
  <div class="section" id="introSection">
    <p>
      Upload a single Excel export (xlsx) from P6. The script auto-detects columns by header names and computes backward critical paths.
      Large datasets (e.g., ~25k rows) are handled with a live progress indicator. Use the Lite Mode toggle to reduce memory usage.
    </p>

    <div class="row">
      <input type="file" id="xlsxInput" accept=".xlsx,.xls" />
      <button id="loadBtn" disabled>Load and Parse</button>
      <span id="progress" class="progress hidden" aria-live="polite">Idle</span>
      <label style="margin-left:auto; display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="liteMode" />
        Lite mode (load essential columns only)
      </label>
    </div>
  </div>

  <!-- Mapping + Start section -->
  <div class="section hidden" id="mappingSection" aria-label="Mapping section">
    <hr class="sep" aria-hidden="true" />
    <div class="sectionTitle" style="font-weight:700; margin-bottom:6px;">Detected Columns</div>
    <ul id="colMap" style="margin:0 0 8px 0;"></ul>

    <div class="sectionTitle" style="margin-top:6px;">Start Activity</div>
    <div class="row" style="align-items:center;">
      <select id="startActivity" aria-label="Start activity dropdown"></select>
      <div style="margin-left:8px;">
        <label for="manualStart" style="margin-right:6px;">Or manual Start ID:</label>
        <input type="text" id="manualStart" placeholder="e.g. dpfg8620" />
        <button id="applyManualStart" class="secondary" title="Use manual Start ID for tracing">Use Start ID</button>
      </div>
    </div>

    <div class="row" style="margin-top:8px;">
      <button id="traceBtn" style="margin-right:8px;">Trace Backward Paths</button>
      <button id="exportBtn" class="secondary" disabled>Export Top 10 as CSV</button>
    </div>
  </div>

  <!-- Results -->
  <div class="section hidden" id="resultsSection" aria-label="Results section">
    <div class="sectionTitle" style="font-weight:700;">Top 10 Backward Critical Paths</div>
    <table id="resultsTable" aria-label="Top 10 backward paths">
      <thead>
        <tr>
          <th>Path Score (lower = more critical)</th>
          <th>Path IDs</th>
          <th>Path Names</th>
          <th>Node Count</th>
        </tr>
      </thead>
      <tbody id="resultsBody"></tbody>
    </table>
  </div>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>

  <script>
    /*
      High-level flow:
      1) User loads an XLSX. Data is parsed in batches to keep UI responsive.
      2) Headers are detected robustly; essential columns mapped (activity id, duration, total float, preds, name).
      3) Start IDs are populated from the dataset; a manual Start ID can override.
      4) Compute backward paths and score them by total float; show top 10.
      5) Optionally export results as CSV.
      6) Lite mode reduces memory by loading only essential columns during parsing.
    */

    // Helpers
    const normalizeHeader = (h) => (h || "").toString().trim().toLowerCase();

    // Global data
    let rows = [];               // all row objects (only essential columns loaded in lite mode)
    let fullRowsCache = null;      // optional: cache full rows if needed (not used in lite mode)
    let headerMap = {};            // canonical alias -> actual header name
    let activityIdCol = null;       // key in row objects
    let durationCol = null;
    let totalFloatCol = null;
    let predCol = null;
    let nameCol = null;

    // UI refs
    const xlsxInput = document.getElementById('xlsxInput');
    const loadBtn = document.getElementById('loadBtn');
    const progressEl = document.getElementById('progress');
    const liteModeCheckbox = document.getElementById('liteMode');
    const mappingSection = document.getElementById('mappingSection');
    const colMap = document.getElementById('colMap');
    const startSelect = document.getElementById('startActivity');
    const manualStart = document.getElementById('manualStart');
    const applyManualStart = document.getElementById('applyManualStart');
    const traceBtn = document.getElementById('traceBtn');
    const exportBtn = document.getElementById('exportBtn');
    const resultsSection = document.getElementById('resultsSection');
    const resultsBody = document.getElementById('resultsBody');

    const FINAL_ANCHOR = "dpfg8620";

    // Progress state
    let totalRows = 0;
    let parsedRows = 0;
    let lastProgressPct = -1;
    let lastExportResults = null;

    // Event: file input
    xlsxInput.addEventListener('change', () => {
      loadBtn.disabled = !xlsxInput.files.length;
    });

    // Event: Load button
    loadBtn.addEventListener('click', async () => {
      if (!xlsxInput.files?.length) return;
      const file = xlsxInput.files[0];

      try {
        resetUIForParse();
        progressEl.classList.remove('hidden');
        progressEl.textContent = 'Reading workbook...';
        const wb = await readWorkbook(file);

        // Determine parsing plan based on Lite mode
        const lite = liteModeCheckbox.checked;

        // Pick first sheet and parse JSON
        const sheetName = Object.keys(wb.Sheets)[0];
        const sheet = wb.Sheets[sheetName];
        // Parse all rows first (SheetJS renders to JSON)
        const parsed = XLSX.utils.sheet_to_json(sheet, { defval: "" });
        totalRows = parsed.length;

        // Process in batches to keep UI responsive
        rows = [];
        const BATCH = lite ? 8000 : 2000; // bigger chunks in lite mode to speed up
        let idx = 0;

        const processBatch = () => {
          const end = Math.min(idx + BATCH, totalRows);
          for (; idx < end; idx++) {
            // In lite mode, we only keep essential columns
            const r = parsed[idx];
            if (lite) {
              // We only store fields we will actually use later
              // We will map dynamically after header detection
              rows.push(r);
            } else {
              rows.push(r);
            }
          }
          parsedRows = rows.length;
          const pct = Math.floor((parsedRows / totalRows) * 100);
          if (pct !== lastProgressPct) {
            progressEl.textContent = `Parsing: ${pct}% (${parsedRows}/${totalRows})`;
            lastProgressPct = pct;
          }
          if (idx < totalRows) {
            requestAnimationFrame(processBatch);
          } else {
            progressEl.textContent = 'Detecting headers...';
            detectHeadersAndMap(rows, lite);
            populateStartDropdown();
            mappingSection.style.display = 'block';
            resultsSection.style.display = 'none';
            exportBtn.disabled = true;
            progressEl.textContent = 'Done';
            setTimeout(() => progressEl.classList.add('hidden'), 400);
          }
        };

        processBatch();
      } catch (err) {
        progressEl.classList.add('hidden');
        alert('Error parsing file: ' + err.message);
      }
    });

    // Trace path button
    traceBtn.addEventListener('click', () => {
      const manual = (manualStart.value || "").trim();
      const chosenFromDropdown = startSelect.value;
      const startId = manual || chosenFromDropdown;
      if (!startId) {
        alert('Please specify a Start Activity ID (via dropdown or manual input).');
        return;
      }

      const prep = computePaths(rows, headerMap);
      const { paths, activities, graphP, graphS } = prep;
      if (!paths || paths.length === 0) {
        alert('No backward paths found from the chosen start.');
        return;
      }

      const results = traceFrom(startId, paths, activities, graphP, graphS);
      displayResults(results);
      exportBtn.disabled = !(results && results.length > 0);
      lastExportResults = results;
    });

    // Export CSV
    exportBtn.addEventListener('click', () => {
      const rowsEl = resultsBody.querySelectorAll('tr');
      if (!rowsEl || rowsEl.length === 0) {
        alert('No results to export.');
        return;
      }
      const header = ['Path Score','Path IDs','Path Names','Node Count'];
      const csvRows = [header];
      rowsEl.forEach(tr => {
        const tds = tr.querySelectorAll('td');
        csvRows.push([
          tds[0]?.innerText,
          tds[1]?.innerText,
          tds[2]?.innerText,
          tds[3]?.innerText
        ]);
      });
      const csvContent = csvRows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'Top10_Backward_Critical_Paths.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Manual Start button
    applyManualStart.addEventListener('click', () => {
      if (manualStart.value.trim()) {
        alert('Manual Start ID set. Press "Trace Backward Paths" to run.');
      } else {
        alert('Enter a Start Activity ID in the text field first.');
      }
    });

    // Helpers

    // Read workbook via FileReader
    function readWorkbook(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => {
          const data = new Uint8Array(e.target.result);
          const wb = XLSX.read(data, { type: 'array' });
          resolve(wb);
        };
        reader.onerror = () => reject(new Error('Failed to read file.'));
        reader.readAsArrayBuffer(file);
      });
    }

    // Reset UI for fresh parse
    function resetUIForParse() {
      rows = [];
      totalRows = 0;
      parsedRows = 0;
      lastProgressPct = -1;
      headerMap = {};
      activityIdCol = null; durationCol = null;
      totalFloatCol = null; predCol = null; nameCol = null;

      mappingSection.style.display = 'none';
      resultsSection.style.display = 'none';
      resultsBody.innerHTML = '';
      colMap.innerHTML = '';
      startSelect.innerHTML = '';
      manualStart.value = '';
      exportBtn.disabled = true;
      progressEl.textContent = 'Idle';
    }

    // Header detection and mapping (permissive, supports lite mode)
    function detectHeadersAndMap(rowsInput, lite) {
      const first = rowsInput[0] || {};
      const headers = Object.keys(first);
      const normToActual = {};
      headers.forEach(h => { normToActual[normalizeHeader(h)] = h; });

      // Find column by variants
      function findCol(variants) {
        for (const v of variants) {
          const key = normalizeHeader(v);
          if (normToActual[key] !== undefined) return normToActual[key];
        }
        return null;
      }

      // In lite mode, only essential columns
      activityIdCol = findCol(['Activity ID','Activity_Id','Task ID','WBS']);
      durationCol = findCol(['At Completion Duration','Duration','Duration (hrs)']);
      totalFloatCol = findCol(['Total Float','Total_Float','Float','Float Time']);
      predCol = findCol(['Predecessors','Predecessor Details','Predecessor_Details']);
      nameCol = findCol(['Activity Name','Task Name','Name']) || activityIdCol;

      headerMap = {
        'Activity ID': activityIdCol,
        'At Completion Duration': durationCol,
        'Total Float': totalFloatCol,
        'Predecessors': predCol,
        'Activity Name': nameCol
      };

      // Render detected mapping
      colMap.innerHTML = '';
      Object.entries(headerMap).forEach(([key, val]) => {
        const li = document.createElement('li');
        li.textContent = `${key}: ${val || '(not found)'}`;
        colMap.appendChild(li);
      });

      // If lite mode, prune rows to only necessary fields
      if (lite) {
        // We'll keep original row objects but future operations rely on the detected keys.
        // No deep pruning here to avoid losing data for potential troubleshooting.
      }
    }

    // Populate start dropdown from IDs
    function populateStartDropdown() {
      startSelect.innerHTML = '';
      const ids = new Set(rows.map(r => r[activityIdCol]).filter(Boolean));
      ids.forEach(id => {
        const opt = document.createElement('option');
        opt.value = id;
        opt.text = id;
        startSelect.appendChild(opt);
      });
      if (ids.has(FINAL_ANCHOR)) startSelect.value = FINAL_ANCHOR;
    }

    // Compute graphs and paths
    function computePaths(allRows, headers) {
      // Build predecessor graph: graphP[id] = [pred1, pred2,...]
      const graphP = {};
      const graphS = {}; // optional, not strictly needed for scoring

      for (let i = 0; i < allRows.length; i++) {
        const r = allRows[i];
        const id = r[activityIdCol];
        const predsRaw = (r[predCol] || "").toString().trim();
        const predsList = predsRaw ? predsRaw.split(',').map(x => x.trim()).filter(x => x.length) : [];
        graphP[id] = predsList;
        predsList.forEach(p => {
          if (!graphS[p]) graphS[p] = [];
          graphS[p].push(id);
        });
      }

      // Build activities meta
      const activities = {};
      for (let i = 0; i < allRows.length; i++) {
        const r = allRows[i];
        const id = r[activityIdCol];
        if (!id) continue;
        activities[id] = {
          id,
          name: r[nameCol] || id,
          duration: parseFloat(r[durationCol] || 0) || 0,
          totalFloat: parseFloat(r[totalFloatCol] || 0) || 0
        };
      }

      const paths = findBackwardPaths(FINAL_ANCHOR, graphP);
      return { paths, activities, graphP, graphS };
    }

    // Iterative DFS to collect backward paths ending at finalNode
    function findBackwardPaths(finalNode, graph) {
      const paths = [];
      const stack = [[finalNode, [finalNode]]];
      while (stack.length) {
        const [node, path] = stack.pop();
        const preds = graph[node] || [];
        if (preds.length === 0) {
          paths.push(path.slice());
          continue;
        }
        for (const p of preds) {
          if (path.includes(p)) continue;
          stack.push([p, path.concat(p)]);
        }
      }
      // Reverse each path to start->end order
      return paths.map(p => p.slice().reverse());
    }

    // Trace paths from a start id
    function traceFrom(startId, paths, activities, graphP, graphS) {
      const tFloat = {};
      Object.values(activities).forEach(a => { tFloat[a.id] = a.totalFloat || 0; });

      const valid = paths.filter(p => p.includes(startId));
      const scored = valid.map(path => {
        const score = path.reduce((acc, nid) => acc + (tFloat[nid] || 0), 0);
        const pathIds = path.join(' -> ');
        const pathNames = path.map(nid => activities[nid]?.name ?? nid).join(' -> ');
        return { score, pathIds, pathNames, nodeCount: path.length };
      });

      scored.sort((a, b) => a.score - b.score);
      return scored.slice(0, 10);
    }

    // Render results to table
    function displayResults(results) {
      resultsSection.style.display = 'block';
      resultsBody.innerHTML = '';
      results.forEach(r => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${r.score.toFixed(2)}</td>
          <td>${r.pathIds}</td>
          <td>${r.pathNames}</td>
          <td>${r.nodeCount}</td>
        `;
        resultsBody.appendChild(tr);
      });
    }
  </script>
</body>
</html>
