[full HTML content here]
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>CPM Backward Path Analyzer</title>
<style>
/* 
  Single-file, self-contained CSS 
  Responsive layout for widths >= 768px 
  Basic light/dark theme support 
*/
:root {
  --color-bg-light: #ffffff;
  --color-text-light: #000000;
  --color-bg-dark: #222222;
  --color-text-dark: #ffffff;
  --color-accent: #007acc;
  --transition-speed: 0.3s;
  --spacing: 0.5rem;
  --border-radius: 4px;
  --panel-width: 300px;
  --log-height-collapsed: 40px;
  --log-height-expanded: 200px;
}

body[data-theme="light"] {
  background-color: var(--color-bg-light);
  color: var(--color-text-light);
}

body[data-theme="dark"] {
  background-color: var(--color-bg-dark);
  color: var(--color-text-dark);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: sans-serif;
}

header, footer {
  padding: var(--spacing);
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: var(--color-accent);
  color: #fff;
}

header button, footer button {
  margin-left: var(--spacing);
}

main {
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: var(--spacing);
  padding: var(--spacing);
  align-items: start;
}

@media (max-width: 1023px) {
  main {
    grid-template-columns: 1fr;
  }
}

/* Left panel for controls */
#leftPanel {
  border: 1px solid #ccc;
  padding: var(--spacing);
  border-radius: var(--border-radius);
}

/* Right panel for results */
#rightPanel {
  display: flex;
  flex-direction: column;
}

/* Cards row */
#dashboardCards {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing);
  margin-bottom: var(--spacing);
}
.card {
  border: 1px solid #ccc;
  border-radius: var(--border-radius);
  padding: var(--spacing);
  flex: 1;
  min-width: 120px;
}

/* Top 3 paths preview */
#top3PathsPreview table {
  width: 100%;
  border-collapse: collapse;
}
#top3PathsPreview th, #top3PathsPreview td {
  border: 1px solid #ccc;
  padding: var(--spacing);
  text-align: left;
}

/* Detailed paths table */
#detailedPathsTable {
  flex: 1;
  overflow: auto;
  border: 1px solid #ccc;
  border-radius: var(--border-radius);
  margin-top: var(--spacing);
}
#detailedPathsTable table {
  width: 100%;
  border-collapse: collapse;
}
#detailedPathsTable th, #detailedPathsTable td {
  border: 1px solid #ccc;
  padding: var(--spacing);
  text-align: left;
}

/* Log panel */
#logPanel {
  max-height: var(--log-height-collapsed);
  overflow: hidden;
  transition: max-height var(--transition-speed) ease-in-out;
  background: #f0f0f0;
  color: #333;
  padding: var(--spacing);
  margin-top: var(--spacing);
  border: 1px solid #ccc;
  border-radius: var(--border-radius);
  font-size: 0.85rem;
}
#logPanel.expanded {
  max-height: var(--log-height-expanded);
  overflow-y: auto;
}
.log-entry {
  margin-bottom: 0.25rem;
  border-bottom: 1px dashed #ccc;
  padding-bottom: 0.25rem;
}
.log-entry:last-child {
  border-bottom: none;
}

/* Footer / acceptance checklist */
#acceptanceChecklist {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing);
}
.checklist-item {
  display: flex;
  align-items: center;
}
.checklist-item input[type="checkbox"] {
  margin-right: 0.25rem;
}

/* Hidden elements or placeholders */
.hidden {
  display: none !important;
}

.buttonRow {
  display: flex;
  gap: var(--spacing);
  margin-top: var(--spacing);
}

/* Basic styling for controls */
input[type="file"], select, input[type="text"], input[type="number"] {
  margin-bottom: var(--spacing);
  width: 100%;
  padding: 0.25rem;
}

label {
  display: block;
  margin-bottom: 0.25rem;
  font-weight: bold;
}

button {
  cursor: pointer;
  padding: 0.5rem 1rem;
  border: none;
  color: #fff;
  background-color: var(--color-accent);
  border-radius: var(--border-radius);
  transition: background-color var(--transition-speed);
}
button:hover {
  background-color: #005c99;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Drag and drop area */
#csvDropArea {
  border: 2px dashed #ccc;
  border-radius: var(--border-radius);
  text-align: center;
  padding: var(--spacing);
  margin-bottom: var(--spacing);
}

#settingsPanel, #helpModal {
  position: fixed;
  top: 10%;
  right: 10%;
  width: var(--panel-width);
  max-width: 90%;
  background: #f9f9f9;
  color: #000;
  border: 1px solid #ccc;
  border-radius: var(--border-radius);
  padding: var(--spacing);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  z-index: 999;
}
#settingsPanel.hidden, #helpModal.hidden {
  display: none;
}
#settingsPanelClose, #helpModalClose {
  float: right;
  cursor: pointer;
  margin: -0.5rem -0.5rem 0 0;
  background-color: transparent;
  color: #000;
  border: none;
  font-size: 1rem;
}
#settingsPanelClose:hover, #helpModalClose:hover {
  color: red;
}
</style>
<script>
/*
  Single-file, self-contained JavaScript
  Implementation of CSV parsing, CPM building, free float, path enumeration,
  ranking, logging, offline file export, etc.
  - No external libraries or network calls.
  - All logic is modularized inside an IIFE to avoid polluting global scope.
*/
(function(){
  "use strict";

  // Global state machine
  const STATE = {
    Idle: "Idle",
    CSVLoaded: "CSVLoaded",
    GraphBuilt: "GraphBuilt",
    Analyzed: "Analyzed",
    ExportReady: "ExportReady"
  };
  let currentState = STATE.Idle;

  // Data / model
  let rawCSVText = "";
  let parsedRows = [];
  let tasksMap = {};       // { activityId: { rowData, index, placeholders, ES, EF, LS, LF, etc. } }
  let adjSuccessors = {};  // adjacency list of successors
  let adjPredecessors = {}; 
  let edgesList = [];      // list of edges with computed FF_edge
  let hasCycle = false;
  let topologicalOrder = [];
  let pathsResult = [];
  let maxPathsReached = false;
  let analysisAborted = false;

  // Config
  let fallbackMode = "strict"; // "strict" or "placeholder"
  let hoursPerDay = 8.0;
  let unitMode = "days";  // or "hours"
  let maxPaths = 250;
  let maxDepth = 500;

  const CSV_REQUIRED_HEADERS = [
    "Project ID","Activity ID","Activity Name","Activity Type","At Completion Duration","Start","Finish",
    "Activity Status","Total Float","Primary Constraint", "Predecessor Details","Predecessors",
    "Successor Details","Successors"
  ];

  let logEntries = [];
  let baseStartDay = 0; // reference for day 0 in CPM

  // Sample CSV data
  const sampleCSV = `Project ID,Activity ID,Activity Name,Activity Type,At Completion Duration,Start,Finish,Activity Status,Total Float,Primary Constraint,Predecessor Details,Predecessors,Successor Details,Successors
P1,A1,"Start Activity","Task",2,2023-10-01,2023-10-03,completed,0,ASAP,,,"FS to A2","A2"
P1,A2,"Second Activity","Task",3,2023-10-03,2023-10-06,in progress,1,ASAP,"FS from A1","A1","FS to A3",A3
P1,A3,"Third Activity with unknown pred","Task",4,2023-10-06,2023-10-10,not started,2,ASAP,"FS from A9999 ; FS from A2","A9999;A2","FS to A4","A4"
P1,A4,"Fourth Activity","Task",3,2023-10-10,2023-10-13,not started,3,ASAP,"FS from A3","A3",,""
P1,A5,"Completed Branch","Task",5,2023-09-25,2023-09-30,completed,0,ASAP,,"","FS to A2","A2"
P1,A6,"Parallel Activity","Task",5,2023-10-02,2023-10-07,in progress,0,ASAP,,"","FS to A4","A4"
P1,A7,"Another branch","Task",2,2023-10-01,2023-10-03,in progress,1,ASAP,,"","", 
P1,A8,"Leaf Activity","Task",0,2023-10-03,2023-10-03,not started,4,ASAP,"FS from A7","A7","", 
P1,A9,"Yet Another Task","Task",3,,,not started,3,ASAP,"FS from A6","A6","", 
P1,A10,"Final Task","Task",2,,,not started,-1,ASAP,"FS from A4 ; FS from A9","A4;A9","", 
`;

  ////////////////////////////////////////////////////////////
  // UTILITY FUNCTIONS
  ////////////////////////////////////////////////////////////

  function logMessage(level, step, msg) {
    const entry = {
      timestamp: new Date().toISOString(),
      level: level,
      step: step,
      message: msg
    };
    logEntries.push(entry);
    renderLogPanel();
  }

  function renderLogPanel() {
    const logPanel = document.getElementById("logPanel");
    if(!logPanel) return;
    // Render log entries
    let html = "";
    for(let i=0; i<logEntries.length; i++){
      const e = logEntries[i];
      html += `<div class="log-entry"><strong>${e.timestamp} [${e.level}] [${e.step}]</strong><br>${sanitizeString(e.message)}</div>`;
    }
    logPanel.innerHTML = html;
  }

  function sanitizeString(str) {
    const div = document.createElement("div");
    div.textContent = str || "";
    return div.innerHTML;
  }

  function updateChecklist() {
    // update acceptance checkboxes
    const chkCSV = document.getElementById("chkCSV");
    const chkGraph = document.getElementById("chkGraph");
    const chkNoCycle = document.getElementById("chkNoCycle");
    const chkCPM = document.getElementById("chkCPM");
    const chkFF = document.getElementById("chkFF");
    const chkPaths = document.getElementById("chkPaths");
    const chkRanks = document.getElementById("chkRanks");
    const chkExport = document.getElementById("chkExport");
    const chkLog = document.getElementById("chkLog");

    chkCSV.checked = (currentState !== STATE.Idle) && (parsedRows.length > 0);
    chkGraph.checked = (currentState === STATE.GraphBuilt || currentState === STATE.Analyzed || currentState === STATE.ExportReady);
    chkNoCycle.checked = !hasCycle;
    chkCPM.checked = edgesList.length > 0; // indicates we did forward/backward pass
    chkFF.checked = edgesList.every(e=> e.hasOwnProperty("FF_edge"));
    chkPaths.checked = (currentState === STATE.Analyzed || currentState === STATE.ExportReady) && pathsResult.length>0;
    chkRanks.checked = pathsResult.length>0 && pathsResult[0].hasOwnProperty("rank");
    chkExport.checked = (currentState === STATE.ExportReady);
    chkLog.checked = (logEntries.length>0);
  }

  function setState(newState) {
    currentState = newState;
    logMessage("INFO", "STATE", "State changed to " + currentState);
    updateChecklist();
    updateUIState();
  }

  function updateUIState() {
    // Update button states
    const buildGraphBtn = document.getElementById("buildGraphBtn");
    const analyzePathsBtn = document.getElementById("analyzePathsBtn");
    const exportBtn = document.getElementById("exportBtn");
    const startActivitySelect = document.getElementById("startActivitySelect");

    buildGraphBtn.disabled = !(currentState === STATE.CSVLoaded);
    analyzePathsBtn.disabled = !(currentState === STATE.GraphBuilt && !hasCycle && startActivitySelect.value);
    exportBtn.disabled = !(currentState === STATE.Analyzed && pathsResult.length>0);

    // Status badges
    document.getElementById("statusIdle").classList.toggle("hidden", currentState !== STATE.Idle);
    document.getElementById("statusCSV").classList.toggle("hidden", currentState !== STATE.CSVLoaded);
    document.getElementById("statusGraph").classList.toggle("hidden", currentState !== STATE.GraphBuilt);
    document.getElementById("statusAnalyze").classList.toggle("hidden", currentState !== STATE.Analyzed);
    document.getElementById("statusExport").classList.toggle("hidden", currentState !== STATE.ExportReady);
  }

  ////////////////////////////////////////////////////////////
  // CSV PARSING & VALIDATION
  ////////////////////////////////////////////////////////////
  function parseCSVText(csvText) {
    // naive CSV parse, split lines, split by commas
    // handle quotes minimally
    logMessage("INFO", "LOAD_CSV", "Parsing CSV text");
    const lines = csvText.split(/\r?\n/);
    if(lines.length <= 1) {
      logMessage("ERROR", "LOAD_CSV", "No data lines found");
      return [];
    }
    const headerLine = lines[0];
    const headers = headerLine.split(",");
    // Basic check for required headers
    for(const req of CSV_REQUIRED_HEADERS) {
      if(!headers.includes(req)) {
        logMessage("ERROR", "VALIDATE_SCHEMA", "Missing required header: " + req);
      }
    }
    const result = [];
    for(let i = 1; i<lines.length; i++){
      const line = lines[i].trim();
      if(!line) continue; // skip empty
      // minimal split
      const rawCols = splitCSVRow(line);
      if(rawCols.length < headers.length) {
        // pad columns
        while(rawCols.length < headers.length) {
          rawCols.push("");
        }
      }
      const rowObj = {};
      for(let c = 0; c<headers.length; c++){
        const colName = headers[c];
        rowObj[colName] = (rawCols[c] || "").trim();
      }
      result.push(rowObj);
    }
    return result;
  }

  function splitCSVRow(row) {
    // Minimal CSV split for demonstration (doesn't fully handle complex quotes)
    const result = [];
    let current = "";
    let inQuotes = false;
    for(let i=0; i<row.length; i++){
      const ch = row[i];
      if(ch === '"' && !inQuotes) {
        inQuotes = true;
      } else if(ch === '"' && inQuotes) {
        // peek next
        if(i+1 < row.length && row[i+1] === '"'){
          current += '"'; 
          i++;
        } else {
          inQuotes = false;
        }
      } else if(ch === ',' && !inQuotes) {
        result.push(current);
        current = "";
      } else {
        current += ch;
      }
    }
    result.push(current);
    return result;
  }

  ////////////////////////////////////////////////////////////
  // BUILD GRAPH
  ////////////////////////////////////////////////////////////
  function buildGraph() {
    logMessage("INFO", "BUILD_GRAPH", "Building graph from parsed rows");
    tasksMap = {};
    adjSuccessors = {};
    adjPredecessors = {};
    edgesList = [];
    hasCycle = false;
    topologicalOrder = [];

    for(let i=0; i<parsedRows.length; i++){
      const row = parsedRows[i];
      const actId = row["Activity ID"];
      if(!actId) {
        logMessage("WARN", "BUILD_GRAPH", "Row " + i + " has empty Activity ID - ignoring");
        continue;
      }
      if(tasksMap[actId]) {
        // Duplicate activity ID
        logMessage("WARN", "BUILD_GRAPH", "Duplicate Activity ID found: " + actId + " (ignoring subsequent)");
        continue;
      }
      const durRaw = parseFloat(row["At Completion Duration"]);
      const duration = isNaN(durRaw)? 0 : durRaw;
      let status = (row["Activity Status"] || "").toLowerCase();
      if(!status) {
        status = "not started";
        logMessage("WARN", "BUILD_GRAPH", "Row " + i + " missing status, defaulting to 'not started'");
      } else if(!["completed","in progress","not started"].includes(status)) {
        status = "not started";
        logMessage("WARN", "BUILD_GRAPH", "Row " + i + " invalid status, defaulting to 'not started'");
      }
      tasksMap[actId] = {
        row: row,
        duration: duration,
        status: status,
        ES: null, EF: null, LS: null, LF: null
      };
      adjSuccessors[actId] = [];
      adjPredecessors[actId] = [];
    }

    // Build edges
    for(const actId in tasksMap) {
      const row = tasksMap[actId].row;
      const predsStr = row["Predecessors"] || "";
      if(predsStr.trim()) {
        const preds = predsStr.split(";").map(x=> x.trim()).filter(x=> x);
        for(const p of preds) {
          if(!tasksMap[p]) {
            if(fallbackMode === "placeholder") {
              // create placeholder
              if(!tasksMap[p]) {
                tasksMap[p] = {
                  row: {},
                  duration: 0,
                  status: "unknown",
                  ES: null, EF: null, LS: null, LF: null
                };
                adjSuccessors[p] = [];
                adjPredecessors[p] = [];
                logMessage("WARN", "BUILD_GRAPH", "Placeholder created for missing predecessor: " + p);
              }
            } else {
              // strict
              logMessage("ERROR", "BUILD_GRAPH", "Predecessor " + p + " not found for " + actId + ", ignoring edge");
              continue; 
            }
          }
          // build adjacency
          if(!adjSuccessors[p]) adjSuccessors[p] = [];
          if(!adjPredecessors[actId]) adjPredecessors[actId] = [];
          if(!adjSuccessors[p].includes(actId)) adjSuccessors[p].push(actId);
          if(!adjPredecessors[actId].includes(p)) adjPredecessors[actId].push(p);
        }
      }
    }

    setState(STATE.GraphBuilt);
  }

  ////////////////////////////////////////////////////////////
  // TOPOLOGICAL SORT, CPM, FREE FLOAT
  ////////////////////////////////////////////////////////////
  function computeCPM() {
    logMessage("INFO", "TOPO_SORT", "Performing Kahn's algorithm topological sort");
    // Kahn's
    const inDegree = {};
    for(const actId in tasksMap) {
      inDegree[actId] = adjPredecessors[actId].length;
    }
    const queue = [];
    for(const actId in inDegree) {
      if(inDegree[actId]===0) queue.push(actId);
    }
    const order = [];
    while(queue.length>0) {
      const u = queue.shift();
      order.push(u);
      for(const succ of adjSuccessors[u]) {
        inDegree[succ]--;
        if(inDegree[succ]===0) {
          queue.push(succ);
        }
      }
    }
    // If order length < tasksMap size => cycle
    if(order.length < Object.keys(tasksMap).length) {
      hasCycle = true;
      logMessage("ERROR", "TOPO_SORT", "Cycle detected! Some nodes remain unsorted.");
      return;
    }
    topologicalOrder = order;

    // Forward pass
    logMessage("INFO", "FORWARD_PASS", "Computing ES/EF");
    // find earliest Start across all tasks
    let earliestStart = null;
    for(const actId in tasksMap) {
      const row = tasksMap[actId].row;
      const s = parseLocalDate(row["Start"]);
      if(s && (earliestStart===null || s < earliestStart)) {
        earliestStart = s;
      }
    }
    if(!earliestStart) {
      earliestStart = new Date(); // fallback to current date if none
    }
    baseStartDay = +earliestStart; // store as ms

    for(const actId in tasksMap) {
      tasksMap[actId].ES = 0;
      tasksMap[actId].EF = 0;
    }

    for(const u of topologicalOrder) {
      // ES(u) = max of EF(p) among predecessors
      let esVal = 0;
      for(const p of adjPredecessors[u]) {
        const predEF = tasksMap[p].EF;
        if(predEF>esVal) esVal = predEF;
      }
      // check if user-provided Start can override
      const rowU = tasksMap[u].row;
      const startDate = parseLocalDate(rowU["Start"]);
      const diffStart = convertMsToDays((startDate? +startDate : baseStartDay) - baseStartDay);
      if(startDate !== null) {
        if(diffStart>esVal) esVal = diffStart;
      }
      tasksMap[u].ES = esVal;
      tasksMap[u].EF = esVal + tasksMap[u].duration;
    }

    // Project finish = max(EF)
    let projectFinish = 0;
    for(const actId in tasksMap) {
      const efVal = tasksMap[actId].EF;
      if(efVal>projectFinish) projectFinish = efVal;
    }

    // Backward pass
    logMessage("INFO", "BACKWARD_PASS", "Computing LS/LF");
    for(const actId in tasksMap) {
      tasksMap[actId].LF = projectFinish;
      tasksMap[actId].LS = projectFinish - tasksMap[actId].duration;
    }

    for(let i=topologicalOrder.length-1; i>=0; i--){
      const u = topologicalOrder[i];
      let lfVal = tasksMap[u].LF;
      for(const succ of adjSuccessors[u]) {
        const succLS = tasksMap[succ].LS;
        if(succLS < lfVal) {
          lfVal = succLS;
        }
      }
      const rowU = tasksMap[u].row;
      // check if user-provided Finish overrides
      const finishDate = parseLocalDate(rowU["Finish"]);
      if(finishDate!==null) {
        const diffFinish = convertMsToDays((+finishDate) - baseStartDay);
        if(diffFinish < lfVal) lfVal = diffFinish; 
      }
      tasksMap[u].LF = lfVal;
      tasksMap[u].LS = lfVal - tasksMap[u].duration;
    }

    // Edge Free Float
    edgesList = [];
    logMessage("INFO", "FF_EDGES", "Computing per-edge free float");
    for(const u in tasksMap) {
      for(const v of adjSuccessors[u]) {
        const esV = tasksMap[v].ES;
        const efU = tasksMap[u].EF;
        if(esV===null || efU===null) {
          logMessage("ERROR", "FF_EDGES", "Missing ES/EF for edge " + u + "->" + v);
          continue;
        }
        const ff = esV - efU; 
        edgesList.push({ u, v, FF_edge: ff });
      }
    }
  }

  function parseLocalDate(str) {
    if(!str) return null;
    const d = new Date(str);
    if(isNaN(+d)) return null;
    return d;
  }

  function convertMsToDays(ms) {
    return ms / (1000*60*60*24);
  }

  ////////////////////////////////////////////////////////////
  // BACKWARD PATH ENUMERATION
  ////////////////////////////////////////////////////////////
  function enumerateBackwardPaths(startId) {
    logMessage("INFO", "ENUMERATE_PATHS", "Enumerating backward paths from " + startId);
    pathsResult = [];
    maxPathsReached = false;
    analysisAborted = false;
    let stack = [{ node: startId, path: [startId], edges: [] }];
    const result = [];

    if(tasksMap[startId].status==="completed") {
      // zero-edge path
      result.push({
        path: [startId],
        edges: [],
        totalFF: 0,
        edgesCount: 0,
        terminalId: startId
      });
    }

    // Iterative DFS
    while(stack.length>0) {
      // check if we reached maxPaths
      if(result.length >= maxPaths) {
        maxPathsReached = true;
        break;
      }
      const top = stack.pop();
      const currentNode = top.node;
      // expand predecessors
      const preds = adjPredecessors[currentNode] || [];
      if(preds.length===0) {
        // no more predecessors
        // do we store if currentNode not completed? only if it leads to a completed node or is self completed
        // Actually we only store if last node is completed or start node was completed
        // But here it's not completed => we do not store
      } else {
        for(const p of preds) {
          if(result.length >= maxPaths) break;
          // check placeholder
          if(tasksMap[p].status==="unknown") {
            // stop expansion
            continue;
          }
          // check repeated node in path => skip
          if(top.path.includes(p)) {
            // skip
            continue;
          }
          const newPath = top.path.concat([p]);
          const newEdges = top.edges.slice();
          // We need the edge forward direction p->(some successor) but we want p-> current
          // find edge free float from p-> current
          const e = edgesList.find(e=> e.u===p && e.v===currentNode);
          let ffVal = (e? e.FF_edge : 0);
          newEdges.push({ u: p, v: currentNode, FF_edge: ffVal });

          if(tasksMap[p].status==="completed") {
            // store path
            const totalFF = newEdges.reduce((acc, x)=> acc + x.FF_edge, 0);
            result.push({
              path: newPath,
              edges: newEdges,
              totalFF: totalFF,
              edgesCount: newEdges.length,
              terminalId: p
            });
          } else {
            // keep searching if depth < maxDepth
            if(newPath.length <= maxDepth) {
              stack.push({
                node: p,
                path: newPath,
                edges: newEdges
              });
            } else {
              logMessage("WARN", "ENUMERATE_PATHS", "Max depth exceeded for path " + newPath.join(">"));
            }
          }
        }
      }
    }

    pathsResult = result.map((r, i)=> {
      return {
        path: r.path,
        edges: r.edges,
        totalFF: r.totalFF,
        edgesCount: r.edgesCount,
        terminalId: r.terminalId
      };
    });
  }

  ////////////////////////////////////////////////////////////
  // PATH RANKING
  ////////////////////////////////////////////////////////////
  function rankPaths() {
    if(!pathsResult || !pathsResult.length) return;
    logMessage("INFO", "RANK_PATHS", "Ranking paths");
    // primary sort: ascending totalFF
    // secondary: ascending edgesCount
    // tertiary: lexicographic
    pathsResult.sort((a,b)=> {
      if(a.totalFF!==b.totalFF) return a.totalFF - b.totalFF;
      if(a.edgesCount!==b.edgesCount) return a.edgesCount - b.edgesCount;
      const aSeq = a.path.join(">");
      const bSeq = b.path.join(">");
      return aSeq.localeCompare(bSeq);
    });
    // assign rank
    for(let i=0; i<pathsResult.length; i++){
      pathsResult[i].rank = i+1;
    }
  }

  ////////////////////////////////////////////////////////////
  // RENDER RESULTS
  ////////////////////////////////////////////////////////////
  function renderResults() {
    // Update dashboard cards
    const actCountCard = document.getElementById("actCountCard");
    const edgeCountCard = document.getElementById("edgeCountCard");
    const cycleCard = document.getElementById("cycleCard");
    const finishCard = document.getElementById("finishCard");
    const analysisTimeCard = document.getElementById("analysisTimeCard");

    actCountCard.textContent = Object.keys(tasksMap).length.toString();
    let eCount = 0;
    for(const u in adjSuccessors) {
      eCount += adjSuccessors[u].length;
    }
    edgeCountCard.textContent = eCount.toString();
    cycleCard.textContent = hasCycle ? "Yes" : "No";
    let pf = 0;
    for(const actId in tasksMap) {
      if(tasksMap[actId].EF>pf) pf = tasksMap[actId].EF;
    }
    finishCard.textContent = pf.toFixed(2) + " days";
    analysisTimeCard.textContent = (new Date()).toLocaleTimeString();

    // Top 3 paths
    const top3Tbl = document.getElementById("top3Tbody");
    top3Tbl.innerHTML = "";
    const top3 = pathsResult.slice(0,3);
    for(const p of top3) {
      const tr = document.createElement("tr");
      const tdRank = document.createElement("td");
      tdRank.textContent = p.rank;
      const tdTotalFF = document.createElement("td");
      tdTotalFF.textContent = formatFF(p.totalFF);
      const tdEdges = document.createElement("td");
      tdEdges.textContent = p.edgesCount.toString();
      const tdBottleneck = document.createElement("td");
      const minFF = p.edges.reduce((acc, e)=> e.FF_edge < acc? e.FF_edge : acc, Infinity);
      tdBottleneck.textContent = formatFF(minFF === Infinity ? 0 : minFF);
      const tdTerminal = document.createElement("td");
      tdTerminal.textContent = p.terminalId;
      const tdPath = document.createElement("td");
      tdPath.textContent = p.path.join(">");
      tr.appendChild(tdRank);
      tr.appendChild(tdTotalFF);
      tr.appendChild(tdEdges);
      tr.appendChild(tdBottleneck);
      tr.appendChild(tdTerminal);
      tr.appendChild(tdPath);
      top3Tbl.appendChild(tr);
    }

    // Detailed paths
    const detailDiv = document.getElementById("detailedPathsTable");
    const table = detailDiv.querySelector("table");
    const tbody = table.querySelector("tbody");
    tbody.innerHTML = "";

    for(const p of pathsResult) {
      const tr = document.createElement("tr");
      const tdRank = document.createElement("td");
      tdRank.textContent = p.rank;
      const tdTotalFF = document.createElement("td");
      tdTotalFF.textContent = formatFF(p.totalFF);
      const tdEdges = document.createElement("td");
      tdEdges.textContent = p.edgesCount.toString();
      const tdBottleneck = document.createElement("td");
      const minFF = p.edges.reduce((acc, e)=> e.FF_edge < acc? e.FF_edge : acc, Infinity);
      tdBottleneck.textContent = formatFF(minFF === Infinity ? 0 : minFF);
      const tdTerminal = document.createElement("td");
      tdTerminal.textContent = p.terminalId;
      const tdPath = document.createElement("td");
      tdPath.textContent = p.path.slice().reverse().join(">"); // show backward or forward?
      const tdEdgeFF = document.createElement("td");
      tdEdgeFF.textContent = p.edges.map(e=> formatFF(e.FF_edge) ).join(";");
      const tdNotes = document.createElement("td");
      tdNotes.textContent = maxPathsReached ? "MaxPaths limit" : "";
      tr.appendChild(tdRank);
      tr.appendChild(tdTotalFF);
      tr.appendChild(tdEdges);
      tr.appendChild(tdBottleneck);
      tr.appendChild(tdTerminal);
      tr.appendChild(tdPath);
      tr.appendChild(tdEdgeFF);
      tr.appendChild(tdNotes);
      tbody.appendChild(tr);
    }
  }

  function formatFF(val) {
    if(unitMode==="hours") {
      return (val*hoursPerDay).toFixed(2) + "h";
    }
    return val.toFixed(2) + "d";
  }

  ////////////////////////////////////////////////////////////
  // EXPORT FILES
  ////////////////////////////////////////////////////////////
  function exportPathsCSV() {
    const lines = [];
    lines.push(["Rank","TotalFF_Days","TotalFF_Hours","EdgesCount","BottleneckFF_Days","BottleneckEdge (u->v)","TerminalCompletedID","PathIDs (Start->...->Terminal)","PerEdgeFF_Days","Aborted","Notes"].join(","));
    for(const p of pathsResult) {
      const minFF = p.edges.reduce((acc, e)=> e.FF_edge<acc? e.FF_edge : acc, Infinity);
      const bEdge = p.edges.find(e=> e.FF_edge===minFF);
      const bottleneckStr = bEdge ? (bEdge.u + "->" + bEdge.v) : "";
      const row = [
        p.rank,
        p.totalFF.toFixed(2),
        (p.totalFF*hoursPerDay).toFixed(2),
        p.edgesCount,
        (minFF===Infinity?0:minFF).toFixed(2),
        bottleneckStr,
        p.terminalId,
        p.path.slice().reverse().join(">"),
        p.edges.map(e=> e.FF_edge.toFixed(2)).join(";"),
        maxPathsReached || analysisAborted ? "true":"false",
        ""
      ];
      lines.push(row.map(x=> `"${x}"`).join(","));
    }
    const csvContent = lines.join("\n");
    downloadFile(csvContent, "Paths.csv", "text/csv");
  }

  function exportSummaryCSV() {
    const lines = [];
    lines.push(["Rank","TotalFF_Days","TotalFF_Hours","EdgesCount","BottleneckFF_Days","BottleneckEdge (u->v)","TerminalCompletedID","PathIDs (Start->...->Terminal)","PerEdgeFF_Days","Aborted","Notes"].join(","));
    const top3 = pathsResult.slice(0,3);
    for(const p of top3) {
      const minFF = p.edges.reduce((acc, e)=> e.FF_edge<acc? e.FF_edge : acc, Infinity);
      const bEdge = p.edges.find(e=> e.FF_edge===minFF);
      const bottleneckStr = bEdge ? (bEdge.u + "->" + bEdge.v) : "";
      const row = [
        p.rank,
        p.totalFF.toFixed(2),
        (p.totalFF*hoursPerDay).toFixed(2),
        p.edgesCount,
        (minFF===Infinity?0:minFF).toFixed(2),
        bottleneckStr,
        p.terminalId,
        p.path.slice().reverse().join(">"),
        p.edges.map(e=> e.FF_edge.toFixed(2)).join(";"),
        maxPathsReached || analysisAborted ? "true":"false",
        ""
      ];
      lines.push(row.map(x=> `"${x}"`).join(","));
    }
    const csvContent = lines.join("\n");
    downloadFile(csvContent, "Summary.csv", "text/csv");
  }

  function exportAnalysisLog() {
    const lines = logEntries.map(e=> {
      return `${e.timestamp} [${e.level}] [${e.step}] ${e.message}`;
    });
    const logText = lines.join("\n");
    downloadFile(logText, "AnalysisLog.txt", "text/plain");
  }

  function downloadFile(content, filename, mime) {
    const blob = new Blob([content], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=> {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
  }

  ////////////////////////////////////////////////////////////
  // UI HANDLERS
  ////////////////////////////////////////////////////////////
  function onLoadSample() {
    rawCSVText = sampleCSV;
    parsedRows = parseCSVText(rawCSVText);
    logMessage("INFO", "LOAD_CSV", "Loaded sample CSV with " + parsedRows.length + " rows");
    if(parsedRows.length>0) {
      setState(STATE.CSVLoaded);
    }
    updateChecklist();
  }

  function onFileSelected(files) {
    if(!files || !files.length) return;
    const file = files[0];
    if(file.size > 10*1024*1024) {
      logMessage("WARN", "LOAD_CSV", "File size exceeds 10 MB limit");
    }
    const reader = new FileReader();
    reader.onload = function(e) {
      rawCSVText = e.target.result;
      parsedRows = parseCSVText(rawCSVText);
      logMessage("INFO", "LOAD_CSV", "Loaded CSV with " + parsedRows.length + " rows");
      if(parsedRows.length>7500) {
        logMessage("WARN", "LOAD_CSV", "Rows exceed 7,500 limit");
      }
      if(parsedRows.length>0) {
        setState(STATE.CSVLoaded);
      }
    };
    reader.onerror = function() {
      logMessage("ERROR", "LOAD_CSV", "File read error");
    };
    reader.readAsText(file);
  }

  function onBuildGraph() {
    setState(STATE.CSVLoaded); // ensure state
    buildGraph();
    if(currentState===STATE.GraphBuilt) {
      computeCPM();
      if(hasCycle) {
        logMessage("ERROR", "CPM", "Cannot proceed due to cycle. Analysis blocked.");
      }
      updateUIState();
    }
  }

  function onAnalyzePaths() {
    if(hasCycle) {
      logMessage("ERROR", "CPM", "Cannot analyze paths due to cycle");
      return;
    }
    const startActivitySelect = document.getElementById("startActivitySelect");
    const startId = startActivitySelect.value;
    if(!startId) {
      logMessage("ERROR", "ENUMERATE_PATHS", "No start ID selected");
      return;
    }
    enumerateBackwardPaths(startId);
    rankPaths();
    setState(STATE.Analyzed);
    renderResults();
    setState(STATE.ExportReady);
  }

  function onExport() {
    exportPathsCSV();
    exportSummaryCSV();
    exportAnalysisLog();
  }

  function resetApp() {
    if(!confirm("Are you sure you want to reset?")) return;
    rawCSVText = "";
    parsedRows = [];
    tasksMap = {};
    adjSuccessors = {};
    adjPredecessors = {};
    edgesList = [];
    pathsResult = [];
    hasCycle = false;
    topologicalOrder = [];
    logEntries = [];
    maxPathsReached = false;
    analysisAborted = false;
    setState(STATE.Idle);
    renderLogPanel();
    document.getElementById("startActivitySelect").innerHTML = "";
    document.getElementById("csvFileInput").value = "";
    renderResults();
    updateUIState();
  }

  function onCancelStop() {
    analysisAborted = true;
    maxPathsReached = true;
    logMessage("WARN", "ENUMERATE_PATHS", "User canceled/stop");
  }

  function onToggleTheme() {
    const body = document.body;
    const currentTheme = body.getAttribute("data-theme");
    body.setAttribute("data-theme", currentTheme==="dark"? "light":"dark");
  }

  function onToggleLogPanel() {
    const logPanel = document.getElementById("logPanel");
    logPanel.classList.toggle("expanded");
  }

  function onUnitToggle() {
    const modeSelect = document.getElementById("unitModeSelect").value;
    unitMode = modeSelect;
    renderResults();
  }

  function onHoursPerDayChange() {
    const val = parseFloat(document.getElementById("hoursPerDayInput").value);
    if(!isNaN(val) && val>=1 && val<=24) {
      hoursPerDay = val;
    }
    renderResults();
  }

  function onFallbackChange() {
    fallbackMode = document.getElementById("fallbackModeSelect").value;
  }

  function onMaxPathsChange() {
    const val = parseInt(document.getElementById("maxPathsInput").value,10);
    if(!isNaN(val) && val>=1) {
      maxPaths = val;
      if(val>10000) logMessage("WARN", "SETTINGS", "maxPaths above 10,000 may be slow");
    }
  }

  function onMaxDepthChange() {
    const val = parseInt(document.getElementById("maxDepthInput").value,10);
    if(!isNaN(val) && val>=10) {
      maxDepth = val;
      if(val>10000) logMessage("WARN", "SETTINGS", "maxDepth above 10,000 may be slow");
    }
  }

  function openSettingsPanel() {
    document.getElementById("settingsPanel").classList.remove("hidden");
  }

  function closeSettingsPanel() {
    document.getElementById("settingsPanel").classList.add("hidden");
  }

  function openHelpModal() {
    document.getElementById("helpModal").classList.remove("hidden");
  }

  function closeHelpModal() {
    document.getElementById("helpModal").classList.add("hidden");
  }

  function onRunSelfTest() {
    // Load sample => build => analyze => check acceptance
    onLoadSample();
    setTimeout(()=>{
      onBuildGraph();
      setTimeout(()=>{
        const startSelect = document.getElementById("startActivitySelect");
        const firstKey = Object.keys(tasksMap)[0];
        startSelect.value = firstKey;
        onAnalyzePaths();
        logMessage("INFO", "SELF_TEST", "Self-test complete");
      },500);
    },500);
  }

  ////////////////////////////////////////////////////////////
  // INIT
  ////////////////////////////////////////////////////////////
  window.addEventListener("DOMContentLoaded", ()=>{
    // default theme
    document.body.setAttribute("data-theme","light");

    // set initial state
    setState(STATE.Idle);

    // drag & drop
    const dropArea = document.getElementById("csvDropArea");
    dropArea.addEventListener("dragenter", (e)=>{ e.preventDefault(); e.stopPropagation(); dropArea.classList.add("dragover"); });
    dropArea.addEventListener("dragover", (e)=>{ e.preventDefault(); e.stopPropagation(); });
    dropArea.addEventListener("dragleave", (e)=>{ e.preventDefault(); e.stopPropagation(); dropArea.classList.remove("dragover"); });
    dropArea.addEventListener("drop", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      dropArea.classList.remove("dragover");
      if(e.dataTransfer.files && e.dataTransfer.files.length) {
        onFileSelected(e.dataTransfer.files);
      }
    });

    // fill startActivitySelect after graph built
    document.getElementById("startActivitySelect").addEventListener("click", (e)=>{
      // populate when needed
      const sel = e.currentTarget;
      sel.innerHTML = "";
      for(const actId in tasksMap) {
        const opt = document.createElement("option");
        opt.value = actId;
        opt.textContent = actId;
        sel.appendChild(opt);
      }
    });

    // keyboard shortcuts
    document.addEventListener("keydown", (e)=>{
      if(e.key==="?") {
        openHelpModal();
      } else if(e.key==="g") {
        onBuildGraph();
      } else if(e.key==="a") {
        onAnalyzePaths();
      } else if(e.key==="e") {
        onExport();
      } else if(e.key==="l") {
        onToggleLogPanel();
      } else if(e.key==="t") {
        onToggleTheme();
      }
    });
  });

})();
</script>
</head>
<body data-theme="light">

<header>
  <div style="font-size:1.25rem;font-weight:bold;">CPM Backward Path Analyzer</div>
  <div>
    <button id="themeToggleBtn" onclick="onToggleTheme()">Toggle Theme</button>
    <button onclick="openHelpModal()">Help</button>
    <button onclick="openSettingsPanel()">Settings</button>
  </div>
</header>

<main>
  <!-- Left Panel -->
  <div id="leftPanel">
    <h3>CSV Input</h3>
    <div id="csvDropArea">Drag & Drop CSV Here</div>
    <input type="file" id="csvFileInput" accept=".csv" onchange="onFileSelected(this.files)" />
    <div class="buttonRow">
      <button onclick="onLoadSample()">Load Sample</button>
    </div>

    <hr />
    <h3>Settings</h3>
    <label>Units:</label>
    <select id="unitModeSelect" onchange="onUnitToggle()">
      <option value="days" selected>Days</option>
      <option value="hours">Hours</option>
    </select>

    <label>Hours/Day:</label>
    <input type="number" id="hoursPerDayInput" value="8" step="0.25" min="1" max="24" onchange="onHoursPerDayChange()" />

    <label>Fallback Mode:</label>
    <select id="fallbackModeSelect" onchange="onFallbackChange()">
      <option value="strict" selected>Strict</option>
      <option value="placeholder">Placeholder</option>
    </select>

    <label>Max Paths:</label>
    <input type="number" id="maxPathsInput" min="1" max="100000" value="250" onchange="onMaxPathsChange()" />

    <label>Max Depth:</label>
    <input type="number" id="maxDepthInput" min="10" max="10000" value="500" onchange="onMaxDepthChange()" />

    <hr />
    <h3>Start & Actions</h3>
    <label>Start Activity ID:</label>
    <select id="startActivitySelect"></select>
    <div class="buttonRow">
      <button id="buildGraphBtn" onclick="onBuildGraph()" disabled>Build Graph</button>
      <button id="analyzePathsBtn" onclick="onAnalyzePaths()" disabled>Analyze Paths</button>
      <button id="cancelBtn" onclick="onCancelStop()">Cancel/Stop</button>
      <button onclick="resetApp()">Reset</button>
    </div>
    <div class="buttonRow">
      <button onclick="onRunSelfTest()">Run Self-Test</button>
    </div>

    <hr />
    <h3>Status</h3>
    <div id="statusIdle">Idle</div>
    <div id="statusCSV" class="hidden">CSV Loaded</div>
    <div id="statusGraph" class="hidden">Graph Built</div>
    <div id="statusAnalyze" class="hidden">Analyzed</div>
    <div id="statusExport" class="hidden">Export Ready</div>
  </div>

  <!-- Right Panel -->
  <div id="rightPanel">
    <div id="dashboardCards">
      <div class="card">
        <strong>Activities:</strong> <span id="actCountCard">0</span>
      </div>
      <div class="card">
        <strong>Edges:</strong> <span id="edgeCountCard">0</span>
      </div>
      <div class="card">
        <strong>Cycle Detected:</strong> <span id="cycleCard">No</span>
      </div>
      <div class="card">
        <strong>Project Finish:</strong> <span id="finishCard">0.00</span>
      </div>
      <div class="card">
        <strong>Analysis Time:</strong> <span id="analysisTimeCard">--:--</span>
      </div>
    </div>

    <div id="top3PathsPreview">
      <h3>Top 3 Paths Preview</h3>
      <table>
        <thead>
          <tr>
            <th>Rank</th>
            <th>Total FF</th>
            <th>Edges</th>
            <th>Bottleneck</th>
            <th>Terminal</th>
            <th>Path</th>
          </tr>
        </thead>
        <tbody id="top3Tbody"></tbody>
      </table>
    </div>

    <div id="detailedPathsTable">
      <h3>Detailed Paths</h3>
      <table>
        <thead>
          <tr>
            <th>Rank</th>
            <th>Total FF</th>
            <th># Edges</th>
            <th>BottleneckFF</th>
            <th>Terminal ID</th>
            <th>Path IDs</th>
            <th>Per-Edge FF</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="buttonRow">
      <button id="exportBtn" onclick="onExport()" disabled>Export</button>
      <button onclick="onToggleLogPanel()">Toggle Log</button>
    </div>

    <div id="logPanel"></div>
  </div>
</main>

<footer>
  <div id="acceptanceChecklist">
    <div class="checklist-item"><input type="checkbox" id="chkCSV" disabled /><label>CSV parsed</label></div>
    <div class="checklist-item"><input type="checkbox" id="chkGraph" disabled /><label>Graph built</label></div>
    <div class="checklist-item"><input type="checkbox" id="chkNoCycle" disabled /><label>No cycles detected</label></div>
    <div class="checklist-item"><input type="checkbox" id="chkCPM" disabled /><label>CPM times computed</label></div>
    <div class="checklist-item"><input type="checkbox" id="chkFF" disabled /><label>Free float computed</label></div>
    <div class="checklist-item"><input type="checkbox" id="chkPaths" disabled /><label>Paths enumerated</label></div>
    <div class="checklist-item"><input type="checkbox" id="chkRanks" disabled /><label>Paths ranked</label></div>
    <div class="checklist-item"><input type="checkbox" id="chkExport" disabled /><label>Output files generated</label></div>
    <div class="checklist-item"><input type="checkbox" id="chkLog" disabled /><label>Log available</label></div>
  </div>
  <div>
    <small>Build info: v1.0 - <span id="analysisTimeCard2"></span></small>
  </div>
</footer>

<!-- Settings Panel -->
<div id="settingsPanel" class="hidden">
  <button id="settingsPanelClose" onclick="closeSettingsPanel()">×</button>
  <h3>Settings</h3>
  <p>Adjust settings in the left panel or here. (This panel is just a demonstration of a modal. All changes should be made in the left panel for simplicity.)</p>
</div>

<!-- Help Modal -->
<div id="helpModal" class="hidden">
  <button id="helpModalClose" onclick="closeHelpModal()">×</button>
  <h3>Help</h3>
  <p>Keyboard Shortcuts:</p>
  <ul>
    <li>? - Open Help</li>
    <li>g - Build Graph</li>
    <li>a - Analyze Paths</li>
    <li>e - Export</li>
    <li>l - Toggle Log</li>
    <li>t - Toggle Theme</li>
  </ul>
</div>

</body>
</html>
