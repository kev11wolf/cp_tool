SYSTEM ROLE You are an expert in CPM (Critical Path Method) scheduling, graph algorithms, and front-end engineering. Your task is to build a production-quality, single-file, offline web application (SPA) that meets all specifications described below, but instead of using the “Predecessors” column for determining the dependency graph, you must parse and interpret the relationships from the “Predecessor Details” column. These relationships will be in the form “ActivityID: RelationshipType optionalLag” (e.g., “DPFG1940: FF -30”), where RelationshipType can be FS (Finish-to-Start), SS (Start-to-Start), SF (Start-to-Finish), or FF (Finish-to-Finish), and optionalLag is a positive or negative integer (default 0 if omitted). Ignore the “Predecessors” column entirely and rely solely on “Predecessor Details” when constructing the unidirectional dependency graph and computing critical paths. Additionally, some activities are set to “as late as possible,” which should be ignored while tracing nodes and computing logic/float computations.

OUTPUT FORMAT (STRICT) HTML Output Produce one complete .html file containing the entire application (named index.html) with fully embedded CSS and JavaScript—no external resources allowed. This file must appear in a code block labeled: [full HTML content here]

Text Copy Immediately after, output a second code block labeled text containing a byte-identical copy of the same HTML content for archival (.txt) purposes—again, no additional commentary or markdown outside these two code blocks.

No Extra Text Do not include any extra commentary, markdown, or explanations outside these two code blocks. Any descriptive text must be confined to in-code (inline) documentation within the single HTML file.

OBJECTIVE Create a single-page application (SPA) named index.html that: • CSV Input

Accepts a CPM schedule exported as a CSV file (see “CSV Input Schema” below). Builds a unidirectional dependency graph using the relationships parsed from the “Predecessor Details” column (ignoring the “Predecessors” column). Has fallback strategies for missing or malformed references. • Free Float (FF) Calculations Computes per-edge Free Float (FF_edge) in days. Provides a toggle to switch displayed units between days and hours. • Backward Path Enumeration Enumerates all backward paths from a user-specified “Starting Activity ID” upstream to the first encountered predecessor whose Activity Status is "completed." Uses only the constructed graph for lookups (do not re-parse CSV strings during graph traversal). • Path Ranking Ranks all found paths by: ascending total free float (sum of FF_edge), then by fewer edges, then by lexicographic order of the path’s Activity ID sequence. Displays a preview of the “Top 3” ranked paths in the UI. • File Downloads Allows the user to download two CSV outputs and one text-based analysis log. • Acceptance Checklist Prints a checklist confirming each required step. • Offline Execution Runs fully offline (no external libraries, fonts, analytics, or network calls). Uses standard browser Web APIs only. • User-Accessible Log Panel Provides a log panel to review processing steps, errors, and logic checkpoints without opening the console. SCOPE & NON-FUNCTIONAL REQUIREMENTS • Single, Self-Contained File

index.html with inline CSS and JavaScript. No external dependencies or assets. • Robust Error Handling Detect and handle invalid CSV schemas, missing/unknown IDs, cycles, numeric/date parsing errors. • Responsive Layout Optimized for desktop and tablet (≥ 1024px width). Must still be functional down to 768px width. • Performance Targets Handle up to 50,000 activities and 20,000 edges. Provide progress updates and allow cancellation if needed. • Cross-Browser Compatibility Latest stable versions of Chrome, Edge, and Firefox. • Clean, Maintainable Code Modular JavaScript (IIFE or inline ES modules). Small, pure functions, clear naming, inline documentation. • Security & Safety No eval. No innerHTML with unsanitized content. Sanitize user-provided text and use textContent. No network calls or external analytics. CSV INPUT SCHEMA Exact, case-sensitive headers: Project ID Activity ID Activity Name Activity Type At Completion Duration Start Finish Activity Status Total Float Primary Constraint Predecessor Details Predecessors Successor Details Successors

Data Parsing Rules: • Whitespace: Trim leading and trailing, keep internal spacing. • Duplicate Activity IDs: Keep the first, log a WARN, ignore subsequent duplicates. • Unknown Predecessor References: Configurable fallback (Strict or Placeholder). • Invalid/Missing Duration: Default to 0; log WARN. • Status Normalization: Lowercase; if invalid/missing, set to "not started"; log WARN. • Dates: Parse local time; if parsing fails, treat as unknown; use CPM to fill. • Maximum CSV Size: 10 MB; if rows exceed 70,500, log a limit warning. • Ignore “as late as possible” constraints by treating them as non-influential for schedule calculations and backward path enumeration.

Relationship Types & Lags (from Predecessor Details column): • Each activity’s “Predecessor Details” may contain multiple relationships, separated by commas. • Each entry has the format “UpstreamID: RelationshipType optionalLag” (e.g. “DPFG1940: FF -30”). • RelationshipType is FS, SS, SF, or FF; optionalLag is a possibly signed integer. • If the lag is omitted, assume 0. • Ignore the “Predecessors” column.

some activites are set to "as late as possible" which should be ignored while tracing nodes
GRAPH MODEL • Nodes

Keyed by ActivityID. Store Duration, Status, optional EarlyStart/LateFinish, computed CPM times (ES, EF, LS, LF), and degree counts. • Edges Directed edges are constructed by parsing the “Predecessor Details” column, from predecessor → successor. Each edge stores: RelationshipType (FS, SS, SF, or FF), lag (integer), FF_edge (computed), references to u (pred) and v (succ). • Adjacency successors[u] = [v...] predecessors[v] = [u...] • Fallbacks (configurable) Strict (default): Ignore edge if predecessor is not found, log ERROR. Placeholder: Create a placeholder node with ActivityID "MISSING:ID", Duration=0, Status="unknown". Placeholders cannot be completed. CPM TIME COMPUTATIONS • Perform standard CPM while respecting FS, SS, SF, or FF relationships and incorporating lag values. • Topological Order: Use Kahn’s Algorithm. If a cycle is detected, log ERROR, show cycle hints (up to 5 nodes), mark state "Invalid Graph", and disable further analysis. • Forward Pass:

FS (Finish-to-Start) edges: ES(succ) = max of EF(pred) + lag over all FS predecessor edges.
FF (Finish-to-Finish) edges: EF(succ) = max of EF(pred) + lag over all FF predecessor edges (then deduce ES if needed).
SS (Start-to-Start) edges: ES(succ) = max of ES(pred) + lag over all SS predecessor edges; EF(succ) = ES(succ) + Duration(succ).
SF (Start-to-Finish) edges: Finish(succ) = max of ES(pred) + lag over all SF predecessor edges; interpret as LF(succ) = that max if needed, then deduce LS(succ).
If no valid predecessors, ES(i) = 0 and EF(i) = Duration(i).
Project Finish Time = PF = max(EF(i)) over all valid nodes. • Backward Pass:
FS edges in backward pass: LS(pred) = min(ES(succ) - lag) across successors.
FF edges in backward pass: LF(pred) = min(EF(succ) - lag) across successors (then deduce LS if needed).
SS edges in backward pass: For an SS edge, LS(succ) is guided by ES(succ). So LS(pred) = min(LS(pred), ES(succ) - lag) across successors if logic requires re-checking.
SF edges in backward pass: For SF edges, we interpret LF(succ) from the forward pass as deriving from ES(pred). Hence LS(pred) or LF(pred) is updated accordingly, using the minimal feasible offset from the SF constraints.
If no successors, LF(i) = PF, LS(i) = PF - Duration(i). • Using Provided EarlyStart/LateFinish If EarlyStart is given, set ES(i) = max(ES(i), EarlyStartDerivedDays) and recompute EF(i). If LateFinish is given, set LF(i) = min(LF(i), LateFinishDerivedDays) and recompute LS(i). • Convert all time to “days from project start” using the earliest known EarlyStart or 0. • Slack Definitions (Reference) Total Float TF(i) = LS(i) - ES(i) = LF(i) - EF(i). PER-EDGE FREE FLOAT (FF_edge) • Definition: For an edge u → v,
If FS: FF_edge(u→v) = ES(v) - [EF(u) + lag].
If FF: FF_edge(u→v) = EF(v) - [EF(u) + lag].
If SS: FF_edge(u→v) = ES(v) - [ES(u) + lag].
If SF: FF_edge(u→v) = LF(v) - [ES(u) + lag] if needed to determine the tension on that start-to-finish relationship. • Units: Days by default; if toggled to hours, multiply by HoursPerDay (default 8.00). • Negative FF: Allowed and indicates tension. Do not clamp. • Validation: If ES/EF are missing or invalid, skip FF computation and log ERROR. BACKWARD PATH ENUMERATION • Goal
Enumerate every simple path (no repeated nodes) traveling upstream via predecessor edges. Start at a chosen StartID and stop at the first encountered predecessor with Status=="completed". If StartID itself is "completed", include a zero-edge path [StartID] with totalFF = 0 and edgesCount = 0. • Traversal Algorithm Iterative DFS with an explicit stack (avoid call stack overflow). Maintain a visited set only for the current path (revisits allowed across different paths, but not within the same path). Stop expansion if: Encounter a "completed" node. Reached a placeholder node (in Placeholder mode, do not go beyond). Exceeded MaxDepth (default 5000), log if triggered. • Performance Controls MaxPaths (default 250) to limit total enumerations. Cancel/Stop button to abort enumeration; partial results remain with an "aborted" flag. • Path Representation A path is [n0, n1, n2, ..., nk] where n0 = StartID and nk has Status=="completed". Edge list in backward traversal is [(n1→n0), (n2→n1), ...], but FF_edge remains defined forward (pred → succ). • Path Metrics totalFF = sum(FF_edge(e)) along the path. edgesCount = number of edges. idSequence = "ActivityID0>ActivityID1>...>ActivityIDk". bottleneckEdgeFF = min(FF_edge(e)) along the path. RANKING • Primary Sort: ascending totalFF (with negative values first). • Secondary Sort: ascending edgesCount. • Tertiary Sort: lexicographic order of idSequence. • Perform a stable sort and include rank numbers.

UNITS, SETTINGS & USER CONTROLS • Units Toggle: Days | Hours (default: Days). • HoursPerDay: numeric, default 8.00, range 1–24, precision 0.25. • Graph Fallbacks: Strict (default) | Placeholder. • MaxPaths: default 250 (range 1–100,000, warning above 10,000). • MaxDepth: default 500 (range 10–10,000). • Start Activity ID: manual user input field, case insensitive. • Buttons: Upload CSV, Build Graph, Analyze Paths, Export, Reset, Cancel/Stop, Toggle Theme.

UI LAYOUT (RESPONSIVE) • Header (sticky)

App title: “CPM Backward Path Analyzer” Theme toggle (Light/Dark), Help button (modal), Settings button (side panel). • Main (two-column grid) Left Panel (Controls) CSV Input (drag-and-drop, file chooser, row count) Settings (units toggle, hours/day, fallback mode, MaxPaths, MaxDepth) Start & Actions (Start Activity dropdown, Build Graph, Analyze, Cancel/Stop, Reset) Status badges (Idle, CSV Loaded, Graph Built, Analyzed, Export Ready) Right Panel (Results) Cards row: activity count, edge count, cycle detected (yes/no), project finish, analysis time. Top 3 Paths Preview: Table of Rank, Total FF, Edges, Bottleneck, Terminal Completed ID, Path. Detailed Paths Table (virtualized): columns for rank, totalFF, edges, bottleneckFF, terminalID, pathIDs, per-edge FF, notes. Sorting, filtering, copy-to-clipboard. Log Panel (collapsible): streaming messages with timestamp, level, step, search box, “Download Log.” • Footer Acceptance Checklist (live-updating). Build info (version, date). Accessibility • Proper aria-label, keyboard navigation, visible focus outline. • Keyboard shortcuts: ? for help, g (Build Graph), a (Analyze), e (Export), l (Toggle Log), t (Toggle Theme).

LOGGING & PROGRESS • Stepwise logging phases: LOAD_CSV, VALIDATE_SCHEMA, BUILD_GRAPH, TOPO_SORT, FORWARD_PASS, BACKWARD_PASS, FF_EDGES, ENUMERATE_PATHS, RANK_PATHS, RENDER, EXPORT. • Show progress bar with sub-step messages and timing. On error, provide guidance.

ERROR HANDLING & VALIDATION • Schema Validation: Check all required headers present once. • Activity ID: Ensure non-empty, unique. • Duration & Dates: If invalid, set to 0 and log WARN. If date parsing fails, log WARN and rely on CPM. • Predecessor References:

Strict: missing IDs → drop edge, WARN. Placeholder: create placeholder nodes (cannot be "completed"). • Cycle Detection: If cycles exist, present sample cycle nodes, block analysis, log last activity id that was analyzed that caused cycle. • Guardrails: Cancel/Stop for long operations with partial results marked "aborted". PERFORMANCE CONSIDERATIONS • Use Kahn’s algorithm (O(V + E)). • Iterative DFS with preallocated stack. • Virtualized rendering for large path tables. • Debounce UI inputs; use requestIdleCallback for low-priority tasks. • Memory usage target: ≤ 900MB for 50k nodes / 20k edges.

OUTPUT FILES • Paths.csv

Columns: Rank, TotalFF_Days, TotalFF_Hours (using HoursPerDay), EdgesCount, BottleneckFF_Days, BottleneckEdge (u→v), TerminalCompletedID, PathIDs (Start→...→Terminal), PerEdgeFF_Days (semicolon-separated), Aborted (true/false), Notes. • Summary.csv Same columns as above, but only top 3 paths. • AnalysisLog.txt Full timestamped log of steps, errors, config snapshot. ACCEPTANCE CHECKLIST • Displayed in the UI with dynamic checkboxes:

CSV parsed (rows > 0, schema validated) Graph built (bidirectional links validated) No cycles detected (or analysis blocked otherwise) CPM times computed (ES/EF/LS/LF) Free float computed for all edges Backward paths enumerated (≥1 or “none found”) Paths ranked, Top 3 preview displayed Output files generated (Paths.csv, Summary.csv, AnalysisLog.txt) Log available for review/download Unit toggle updates UI and export previews STATE MACHINE • States: Idle → CSVLoaded → GraphBuilt → Analyzed → ExportReady • Control Availability:

“Build Graph”: enabled when CSVLoaded “Analyze Paths”: enabled when GraphBuilt + StartID chosen + no cycles “Export”: enabled when Analyzed + at least 1 path (or partial if aborted) “Cancel/Stop”: visible during long phases “Reset”: always available (with confirmation) SECURE CODING & IMPLEMENTATION NOTES • Use DOM APIs with textContent only; sanitize any dynamic HTML if unavoidable. • File handling via FileReader; export via Blob and URL.createObjectURL. • Local preference storage (localStorage) with quota checks. • Time measurement with performance.now(); log durations. • Avoid blocking the UI; chunk large loops with await queueMicrotask or setTimeout(0).

TESTING & SELF-CHECK • Provide a “Run Self-Test” action (or equivalent) that:

Verifies invariants (e.g., edgesCount matches path segments - 1). Logs PASS/FAIL along with any warnings. Checks acceptance items in the UI if successful. CONSTRAINTS • No external JS/CSS libraries or fonts. • No network calls. • Must run offline in a modern browser. • Display all process steps in the log panel.

DELIVERABLE A single .html file named index.html that meets all the requirements above, plus the associated logging and file downloads. Remember the strict output format: one code block labeled html, then one code block labeled text, both containing identical content and nothing else. No additional commentary or markdown is allowed outside those blocks.
